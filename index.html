<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#000000">
    <title>AI Pro Cam (Max Res)</title>

    <!-- æ ¸å¿ƒé‹ç®—åº« -->
    <script async src="https://docs.opencv.org/4.5.0/opencv.js" onload="onOpenCvReady();"></script>

    <style>
        :root { --accent: #00d2ff; --warn: #ffd700; --track: #00ff00; --bg: #000; --ultra: #ff00ff; }
        
        body { 
            margin: 0; background: var(--bg); font-family: -apple-system, system-ui, sans-serif; 
            color: white; height: 100dvh; display: flex; flex-direction: column; overflow: hidden; 
            user-select: none; -webkit-user-select: none; 
        }
        
        /* é ‚éƒ¨ */
        .top-bar { 
            position: absolute; top: 0; left: 0; right: 0; z-index: 20;
            background: linear-gradient(to bottom, rgba(0,0,0,0.9), transparent);
            padding: 10px; padding-top: max(10px, env(safe-area-inset-top));
            display: flex; flex-direction: column; gap: 8px; pointer-events: none;
        }
        .top-bar > * { pointer-events: auto; }

        .row { display: flex; justify-content: space-between; align-items: center; }
        .scroll-x { overflow-x: auto; padding-bottom: 5px; display: flex; gap: 8px; scrollbar-width: none; }

        /* é¡é ­æŒ‰éˆ• */
        .cam-pill {
            background: rgba(40,40,40,0.9); padding: 6px 12px; border-radius: 20px; 
            font-size: 12px; border: 1px solid #555; color: #ccc; white-space: nowrap; transition: 0.2s; cursor: pointer;
        }
        .cam-pill.active { background: #fff; color: #000; border-color: #fff; font-weight: bold; }
        .cam-pill.warn { border-color: var(--warn); color: var(--warn); }
        .cam-pill.warn.active { background: var(--warn); color: #000; }

        /* åŠŸèƒ½æŒ‰éˆ• */
        .tool-btn {
            background: rgba(40,40,40,0.8); border: 1px solid #555; color: #ccc;
            padding: 5px 10px; border-radius: 10px; font-size: 12px; display: flex; align-items: center; gap: 5px; white-space: nowrap; backdrop-filter: blur(4px);
        }
        .tool-btn.active { border-color: var(--accent); color: var(--accent); background: rgba(0, 210, 255, 0.15); font-weight: bold; }
        .tool-btn.hdr-active { border-color: var(--warn); color: var(--warn); background: rgba(255, 215, 0, 0.15); }
        .tool-btn.ultra-active { border-color: var(--ultra); color: var(--ultra); background: rgba(255, 0, 255, 0.15); text-shadow: 0 0 5px rgba(255,0,255,0.5); font-weight: bold; }

        .fs-btn {
            width: 32px; height: 32px; border-radius: 50%; background: rgba(50,50,50,0.8);
            border: 1px solid #666; color: #fff; display: flex; justify-content: center; align-items: center;
            font-size: 16px; cursor: pointer; backdrop-filter: blur(4px);
        }

        .light-group { display: flex; background: rgba(40,40,40,0.9); border-radius: 8px; border: 1px solid #555; padding: 2px; }
        .light-btn { padding: 5px 10px; font-size: 14px; cursor: pointer; border-radius: 6px; border: none; background: transparent; color: #888; }
        .light-btn.active { background: var(--warn); color: #000; font-weight: bold; }

        /* è¦–çª— */
        .viewport { 
            position: relative; flex-grow: 1; background: #000; 
            display: flex; justify-content: center; align-items: center; overflow: hidden;
        }
        video { width: 100%; height: 100%; object-fit: contain; }
        canvas.overlay { position: absolute; top:0; left:0; width: 100%; height: 100%; object-fit: contain; pointer-events: none; z-index: 10; }

        /* ç‹€æ…‹æ–‡å­— */
        #scan-status {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            background: rgba(0,0,0,0.6); padding: 5px 15px; border-radius: 20px;
            color: #fff; font-size: 14px; display: none; z-index: 15;
        }

        /* HUD */
        #mask {
            position: absolute; inset: 0; background: rgba(0,0,0,0.85); z-index: 50;
            display: none; justify-content: center; align-items: center; flex-direction: column;
        }
        .spinner {
            width: 40px; height: 40px; border: 4px solid #333; border-top: 4px solid var(--accent); 
            border-radius: 50%; animation: spin 0.8s infinite linear; margin-bottom: 15px;
        }
        @keyframes spin { 100% { transform: rotate(360deg); } }

        /* åº•éƒ¨ */
        .controls { 
            background: linear-gradient(to top, #000 0%, rgba(0,0,0,0.8) 80%, transparent 100%); 
            padding: 15px; padding-bottom: max(20px, env(safe-area-inset-bottom));
            display: flex; flex-direction: column; gap: 10px; z-index: 20;
        }

        .mode-ribbon {
            display: flex; gap: 30px; overflow-x: auto; padding: 10px 35%; justify-content: center;
            scrollbar-width: none; margin-bottom: 5px;
        }
        .mode-item {
            font-size: 14px; font-weight: 600; color: #666; white-space: nowrap; 
            text-transform: uppercase; transition: 0.2s; letter-spacing: 1px;
        }
        .mode-item.active { color: var(--warn); transform: scale(1.15); text-shadow: 0 0 10px rgba(255, 215, 0, 0.4); }

        .sliders-container { display: flex; flex-direction: column; gap: 8px; margin-bottom: 10px; }
        .slider-row { display: flex; align-items: center; gap: 10px; font-size: 11px; font-weight: bold; color: #aaa; }
        .label { width: 40px; text-align: right; }
        input[type=range] { flex-grow: 1; accent-color: var(--accent); height: 4px; }
        
        .shutter-area { display: flex; justify-content: center; align-items: center; margin-top: 5px; }
        .shutter {
            width: 72px; height: 72px; border-radius: 50%; border: 4px solid rgba(255,255,255,0.4);
            background: white; cursor: pointer; transition: 0.1s; box-shadow: 0 0 15px rgba(255,255,255,0.2);
        }
        .shutter:active { transform: scale(0.92); }

        #info-pill {
            position: absolute; top: 15px; left: 15px;
            background: rgba(0,0,0,0.6); padding: 4px 10px; border-radius: 15px;
            font-size: 10px; color: #fff; pointer-events: none; z-index: 10;
            backdrop-filter: blur(4px); margin-top: max(0px, env(safe-area-inset-top));
        }
        .warn-mode { color: var(--warn) !important; border-color: var(--warn) !important; }

        #focus-reticle {
            position: absolute; width: 60px; height: 60px; border: 2px solid #fff; border-radius: 8px;
            display: none; pointer-events: none; z-index: 30; transform: translate(-50%, -50%);
        }
        #focus-reticle.focusing { animation: focus-anim 0.5s ease-out forwards; }
        @keyframes focus-anim { 0% { width:80px; height:80px; opacity:1; } 100% { width:60px; height:60px; border-color:#0f0; opacity:0; } }

        .af-btn {
            background: rgba(50,50,50,0.8); color: #fff; border: 1px solid #666; padding: 2px 4px; border-radius: 4px; font-size: 10px; cursor: pointer; width: 35px; text-align: center;
        }
        .af-btn.manual { background: var(--warn); color: #000; font-weight: bold; }
    </style>
</head>
<body>

    <div class="top-bar">
        <div class="row">
            <div id="camList" class="scroll-x" style="flex-grow:1; margin-right:10px;"></div>
            <div class="fs-btn" onclick="toggleFullScreen()">â›¶</div>
        </div>
        
        <div class="row scroll-x" style="margin-top:8px;">
             <div class="light-group">
                <button class="light-btn active" id="light-off" onclick="setLightMode('off')">ğŸš«</button>
                <button class="light-btn" id="light-flash" onclick="setLightMode('flash')">âš¡</button>
                <button class="light-btn" id="light-torch" onclick="setLightMode('torch')">ğŸ”¦</button>
             </div>
             
             <div style="width:1px; height:20px; background:#555; margin:0 5px;"></div>

             <select id="hdrCount" style="background:#333; color:#fff; border:none; border-radius:4px; font-size:11px;">
                 <option value="3">3x</option><option value="5">5x</option>
             </select>
             <div class="tool-btn" id="hdrBtn" onclick="toggleFeature('hdr')">HDR</div>
             <div class="tool-btn" id="upscaleBtn" onclick="cycleUpscale()">AI é—œ</div>
             <div class="tool-btn active" id="claheBtn" onclick="toggleFeature('clahe')">é€šé€</div>
             <div class="tool-btn active" id="denoiseBtn" onclick="toggleFeature('denoise')">é™å™ª</div>
        </div>
    </div>

    <div class="viewport" id="viewport">
        <video id="video" autoplay playsinline muted></video>
        <canvas id="cOverlay" class="overlay"></canvas>
        <div id="info-pill">Initializing...</div>
        <div id="scan-status">å°‹æ‰¾æ–‡ä»¶ä¸­...</div>
        <div id="focus-reticle"></div>
        
        <div id="mask">
            <div class="spinner"></div>
            <div id="maskText" style="color:#fff; font-size:16px; font-weight:bold; letter-spacing:1px;">Processing...</div>
            <div id="maskSub" style="color:#aaa; font-size:12px; margin-top:5px;"></div>
        </div>
    </div>

    <div class="controls">
        <div class="mode-ribbon">
            <div class="mode-item active" onclick="setMode('PRO')">PRO</div>
            <div class="mode-item" onclick="setMode('SCAN')">æƒæ</div>
        </div>

        <div class="sliders-container" id="proPanel">
            <!-- ISO å·²ç§»é™¤ -->
            <div class="slider-row">
                <span class="label">EV</span>
                <input type="range" id="evSlider" min="-3" max="3" step="0.5" value="0" oninput="updateHW('ev', this.value)">
                <span id="evVal" style="width:30px; text-align:right">0</span>
            </div>
            <div class="slider-row">
                <span class="label">Zoom</span>
                <input type="range" id="zoomSlider" min="1" max="8" step="0.1" value="1" oninput="updateHW('zoom', this.value)">
                <span id="zoomVal" style="width:30px; text-align:right">1x</span>
            </div>
            <div class="slider-row">
                <span class="label">Focus</span>
                <input type="range" id="focusSlider" min="0" max="100" step="1" value="0" disabled oninput="updateHW('focus', this.value)">
                <div id="afBtn" class="af-btn" onclick="toggleFocusMode()">AF</div>
            </div>
            <div class="slider-row">
                <span class="label">éŠ³åŒ–</span>
                <input type="range" id="sharpSlider" min="0" max="100" value="50">
                <span id="sharpVal" style="width:30px; text-align:right">50</span>
            </div>
        </div>

        <div class="shutter-area">
            <div class="shutter" onclick="captureAction()"></div>
        </div>
    </div>

<script>
    const video = document.getElementById('video');
    const cOverlay = document.getElementById('cOverlay');
    const ctxOverlay = cOverlay.getContext('2d');
    const mask = document.getElementById('mask');
    const maskText = document.getElementById('maskText');
    const maskSub = document.getElementById('maskSub');
    const infoPill = document.getElementById('info-pill');
    const scanStatus = document.getElementById('scan-status');
    
    let stream, videoTrack, imageCapture;
    let currentMode = 'PRO';
    let isOpenCvReady = false;
    
    let features = { hdr: false, upscaleMode: 0, clahe: true, denoise: true }; 
    let hwParams = { zoom: false, torch: false, exp: false, focus: false };
    let lightMode = 'off';
    let isManualFocus = false;
    let isSafeMode = false;
    let scanContour = null; 

    function onOpenCvReady() { isOpenCvReady = true; console.log("OpenCV Ready"); }

    async function init() {
        try {
            stream = await navigator.mediaDevices.getUserMedia({ 
                video: { facingMode: 'environment', width: {ideal: 3840}, height: {ideal: 2160} } 
            });
            setupStream(stream);
            
            const devs = await navigator.mediaDevices.enumerateDevices();
            const cams = devs.filter(d => d.kind === 'videoinput');
            const camList = document.getElementById('camList');
            camList.innerHTML = '';
            
            cams.forEach((c, i) => {
                const d = document.createElement('div');
                d.className = 'cam-pill';
                d.dataset.id = c.deviceId;
                
                let label = c.label.toLowerCase();
                let name = `é¡é ­ ${i+1}`;
                let isWide = false;
                
                if (label.includes('front')) name = 'å‰é¡';
                else if (i === 0) name = 'ä¸»é¡';
                else if (i === 2 && cams.length > 2) { 
                    name = 'å»£è§’ 0.5x'; 
                    isWide = true; 
                    d.classList.add('warn'); 
                } 
                else if (i === 3) name = '1 X';
                
                d.innerText = name;
                d.onclick = () => switchCam(c.deviceId, isWide);
                camList.appendChild(d);
            });
            
            document.getElementById('viewport').addEventListener('click', triggerTapFocus);
            requestAnimationFrame(renderLoop);

        } catch(e) { alert("Camera Init Failed: " + e.message); }
    }

    function setupStream(s) {
        video.srcObject = s;
        videoTrack = s.getVideoTracks()[0];
        try { imageCapture = new ImageCapture(videoTrack); } catch(e){}
        
        const caps = videoTrack.getCapabilities ? videoTrack.getCapabilities() : {};
        hwParams.zoom = !!caps.zoom;
        hwParams.torch = !!caps.torch;
        hwParams.exp = !!caps.exposureCompensation;
        hwParams.focus = caps.focusMode && caps.focusMode.includes('manual');

        const zs = document.getElementById('zoomSlider');
        if(hwParams.zoom) { zs.disabled = false; zs.min = caps.zoom.min; zs.max = caps.zoom.max; } else zs.disabled = true;
        
        video.onloadedmetadata = () => {
            cOverlay.width = video.videoWidth;
            cOverlay.height = video.videoHeight;
            // è®€å– Photo Capabilities å˜—è©¦ç²å–æœ€é«˜è§£æåº¦è³‡è¨Š
            if(imageCapture) {
                imageCapture.getPhotoCapabilities().then(caps => {
                    infoPill.innerText = `Max Photo: ${caps.imageWidth.max}x${caps.imageHeight.max}`;
                }).catch(()=>{
                    infoPill.innerText = `Stream: ${video.videoWidth}x${video.videoHeight}`;
                });
            } else {
                infoPill.innerText = `${video.videoWidth}x${video.videoHeight}`;
            }
        };
    }

    async function switchCam(id, isWide) {
        document.querySelectorAll('.cam-pill').forEach(pill => {
            if (pill.dataset.id === id) pill.classList.add('active');
            else pill.classList.remove('active');
        });

        if(stream) stream.getTracks().forEach(t => t.stop());
        isSafeMode = isWide;
        
        // å˜—è©¦è«‹æ±‚ 4Kï¼Œä½†ä¸»è¦ä¾è³´ takePhoto æŠ“æœ€å¤§å€¼
        let constraints = { video: { deviceId: {exact: id}, width: {ideal: 3840}, height: {ideal: 2160} } };

        try {
            stream = await navigator.mediaDevices.getUserMedia(constraints);
        } catch(e) {
            stream = await navigator.mediaDevices.getUserMedia({ video: { deviceId: {exact: id} } });
        }
        setupStream(stream);
    }

    function toggleFullScreen() {
        if (!document.fullscreenElement) document.documentElement.requestFullscreen().catch(e=>{alert("iOS è«‹ç”¨åŠ å…¥ä¸»ç•«é¢")});
        else document.exitFullscreen();
    }

    async function setLightMode(mode) {
        lightMode = mode;
        document.querySelectorAll('.light-btn').forEach(b => b.classList.remove('active'));
        document.getElementById(`light-${mode}`).classList.add('active');
        
        if(videoTrack && hwParams.torch) {
            await videoTrack.applyConstraints({ advanced: [{ torch: mode === 'torch' }] }).catch(()=>{});
        }
    }

    function updateHW(type, val) {
        if(!videoTrack) return;
        let constraints = { advanced: [] };
        if(type === 'zoom') {
            document.getElementById('zoomVal').innerText = parseFloat(val).toFixed(1) + 'x';
            constraints.advanced.push({ zoom: parseFloat(val) });
        } else if (type === 'ev') {
            document.getElementById('evVal').innerText = val;
            constraints.advanced.push({ exposureCompensation: parseFloat(val) });
        } else if (type === 'focus' && isManualFocus) {
            constraints.advanced.push({ focusMode: 'manual', focusDistance: val/100 });
        }
        videoTrack.applyConstraints(constraints).catch(e=>{});
        
        if(type === 'sharp') document.getElementById('sharpVal').innerText = val;
    }

    async function triggerTapFocus(e) {
        if(isManualFocus || !videoTrack) return;
        const rect = video.getBoundingClientRect();
        const reticle = document.getElementById('focus-reticle');
        reticle.style.left = `${e.clientX}px`;
        reticle.style.top = `${e.clientY}px`;
        reticle.style.display = 'block';
        reticle.classList.remove('focusing');
        void reticle.offsetWidth;
        reticle.classList.add('focusing');
        
        try { await videoTrack.applyConstraints({ advanced: [{ focusMode: 'continuous' }] }); } catch(e){}
    }

    function toggleFocusMode() {
        if(!hwParams.focus) return;
        isManualFocus = !isManualFocus;
        const btn = document.getElementById('afBtn');
        const slider = document.getElementById('focusSlider');
        if(isManualFocus) {
            btn.innerText = "MF"; btn.classList.add('manual');
            slider.disabled = false;
        } else {
            btn.innerText = "AF"; btn.classList.remove('manual');
            slider.disabled = true;
            videoTrack.applyConstraints({ advanced: [{ focusMode: 'continuous' }] }).catch(()=>{});
        }
    }

    function toggleFeature(feat) {
        features[feat] = !features[feat];
        const btn = document.getElementById(`${feat}Btn`);
        if (feat === 'hdr') btn.classList.toggle('hdr-active', features[feat]);
        else btn.classList.toggle('active', features[feat]);
    }

    function cycleUpscale() {
        const btn = document.getElementById('upscaleBtn');
        features.upscaleMode = (features.upscaleMode + 1) % 3;
        
        if (features.upscaleMode === 0) {
            btn.innerText = "AI é—œ";
            btn.classList.remove('active', 'ultra-active');
        } else if (features.upscaleMode === 1) {
            btn.innerText = "2x AI";
            btn.classList.add('active');
            btn.classList.remove('ultra-active');
        } else {
            btn.innerText = "Ultra";
            btn.classList.remove('active');
            btn.classList.add('ultra-active');
        }
    }

    async function setMode(mode) {
        if(currentMode === mode) return;
        currentMode = mode;
        document.querySelectorAll('.mode-item').forEach(el => 
            el.classList.toggle('active', el.innerText === { 'PRO':'PRO', 'SCAN':'æƒæ' }[mode]));
        document.getElementById('proPanel').style.display = (mode === 'PRO') ? 'flex' : 'none';
        scanStatus.style.display = (mode === 'SCAN') ? 'block' : 'none';
    }

    async function renderLoop() {
        if(video.readyState === 4) {
            ctxOverlay.clearRect(0, 0, cOverlay.width, cOverlay.height);
            if (currentMode === 'SCAN' && isOpenCvReady) runScanPreview();
        }
        requestAnimationFrame(renderLoop);
    }

    function runScanPreview() {
        try {
            let src = new cv.Mat(video.videoHeight, video.videoWidth, cv.CV_8UC4);
            let cap = new cv.VideoCapture(video);
            cap.read(src);
            let gray = new cv.Mat();
            cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
            cv.GaussianBlur(gray, gray, new cv.Size(5, 5), 0);
            cv.Canny(gray, gray, 75, 200);
            
            let contours = new cv.MatVector();
            let hierarchy = new cv.Mat();
            cv.findContours(gray, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);
            
            let maxArea = 0; let bestCnt = null;
            for(let i=0; i<contours.size(); ++i) {
                let cnt = contours.get(i);
                let area = cv.contourArea(cnt);
                if(area > 1000) { 
                    let approx = new cv.Mat();
                    cv.approxPolyDP(cnt, approx, 0.04 * cv.arcLength(cnt, true), true);
                    if(approx.rows === 4 && area > maxArea) {
                        maxArea = area; if(bestCnt) bestCnt.delete(); bestCnt = approx;
                    } else approx.delete();
                }
            }
            if(bestCnt) {
                scanStatus.innerText = "å·²é–å®šæ–‡ä»¶";
                scanStatus.style.color = "#0f0";
                
                ctxOverlay.strokeStyle = '#00ff00'; ctxOverlay.lineWidth = 5; ctxOverlay.beginPath();
                let pts = [];
                for(let i=0; i<4; i++) pts.push({x: bestCnt.data32S[i*2], y: bestCnt.data32S[i*2+1]});
                ctxOverlay.moveTo(pts[0].x, pts[0].y);
                for(let i=1; i<4; i++) ctxOverlay.lineTo(pts[i].x, pts[i].y);
                ctxOverlay.closePath(); ctxOverlay.stroke();
                scanContour = pts; bestCnt.delete();
            } else {
                scanStatus.innerText = "å°‹æ‰¾æ–‡ä»¶ä¸­...";
                scanStatus.style.color = "#fff";
                scanContour = null;
            }
            src.delete(); gray.delete(); contours.delete(); hierarchy.delete();
        } catch(e) {}
    }

    // --- æ‹æ”æ ¸å¿ƒ (å¼·åˆ¶ä½¿ç”¨ takePhoto ç²å–å…¨åƒç´ ) ---
    async function captureAction() {
        showMask("è™•ç†ä¸­...");
        try {
            let canvas;
            
            // åš´æ ¼ï¼šç›´æ¥å‘¼å« grabFrame (å…§éƒ¨ä½¿ç”¨ takePhoto)
            // ä¸å†ä½¿ç”¨ preview æˆªåœ–åšå‚™æ¡ˆï¼Œå¤±æ•—å°±å ±éŒ¯
            if (features.hdr) {
                maskText.innerText = "HDR...";
                canvas = await captureHDR(parseInt(document.getElementById('hdrCount').value));
            } else {
                canvas = await grabFrame();
            }

            if (!canvas) throw new Error("Hardware Capture Failed");

            if (currentMode === 'SCAN') {
                if(scanContour && isOpenCvReady) {
                    canvas = performScanCrop(canvas, scanContour);
                    saveImage(canvas, "Doc");
                } else {
                    saveImage(canvas, "Doc_Full");
                }
            } else {
                // Pro Mode
                if(isOpenCvReady) {
                    maskSub.innerText = "AI å„ªåŒ–ä¸­...";
                    canvas = processEnhance(canvas);
                }
                saveImage(canvas, "Pro");
            }
            
        } catch(e) { 
            console.error(e);
            alert("æ‹æ”å¤±æ•—ï¼šç„¡æ³•å–å¾—ç¡¬é«”ç…§ç‰‡ï¼Œè«‹ç¢ºèªç€è¦½å™¨æ”¯æ´åº¦");
        }
        hideMask();
    }

    function performScanCrop(canvas, contourPts) {
        let src = cv.imread(canvas);
        let dst = new cv.Mat();
        let pts = contourPts.sort((a,b) => a.y - b.y);
        let top = pts.slice(0, 2).sort((a,b) => a.x - b.x);
        let bottom = pts.slice(2, 4).sort((a,b) => a.x - b.x);
        let srcPts = [top[0].x, top[0].y, top[1].x, top[1].y, bottom[1].x, bottom[1].y, bottom[0].x, bottom[0].y];
        
        let w = Math.max(Math.hypot(srcPts[2]-srcPts[0], srcPts[3]-srcPts[1]), Math.hypot(srcPts[4]-srcPts[6], srcPts[5]-srcPts[7]));
        let h = Math.max(Math.hypot(srcPts[6]-srcPts[0], srcPts[7]-srcPts[1]), Math.hypot(srcPts[4]-srcPts[2], srcPts[5]-srcPts[3]));
        
        let srcTri = cv.matFromArray(4, 1, cv.CV_32FC2, srcPts);
        let dstTri = cv.matFromArray(4, 1, cv.CV_32FC2, [0,0, w,0, w,h, 0,h]);
        let M = cv.getPerspectiveTransform(srcTri, dstTri);
        
        cv.warpPerspective(src, dst, M, new cv.Size(w, h));
        let resC = document.createElement('canvas');
        resC.width = w; resC.height = h;
        cv.imshow(resC, dst);
        src.delete(); dst.delete(); srcTri.delete(); dstTri.delete(); M.delete();
        return resC;
    }

    function processEnhance(cvs) {
        let src = cv.imread(cvs);
        let dst = new cv.Mat();
        let lab = new cv.Mat();
        try {
            cv.cvtColor(src, lab, cv.COLOR_RGBA2RGB);
            cv.cvtColor(lab, lab, cv.COLOR_RGB2Lab);
            let planes = new cv.MatVector();
            cv.split(lab, planes);
            let L = planes.get(0);

            if(features.denoise) {
                let temp = new cv.Mat();
                cv.bilateralFilter(L, temp, 5, 50, 50, cv.BORDER_DEFAULT);
                temp.copyTo(L); temp.delete();
            }
            if(features.clahe) {
                let clahe = new cv.CLAHE(2.0, new cv.Size(8, 8));
                clahe.apply(L, L); clahe.delete();
            }
            let sharpVal = parseInt(document.getElementById('sharpSlider').value);
            if(sharpVal > 0) {
                let blurred = new cv.Mat();
                cv.GaussianBlur(L, blurred, new cv.Size(0,0), 3);
                cv.addWeighted(L, 1 + (sharpVal/50), blurred, -(sharpVal/50), 0, L);
                blurred.delete();
            }
            planes.set(0, L); cv.merge(planes, lab); cv.cvtColor(lab, dst, cv.COLOR_Lab2RGB);

            // â˜…â˜…â˜… å¼·åˆ¶ AI æ”¾å¤§é‚è¼¯ â˜…â˜…â˜…
            if(features.upscaleMode > 0) {
                let currentW = dst.cols;
                let currentH = dst.rows;
                
                // Ultra æ¨¡å¼ç›®æ¨™ï¼š1å„„ç•«ç´  (100MP) -> ç´„ 12000 x 8500
                // 2x æ¨¡å¼ç›®æ¨™ï¼šè§£æåº¦ * 2 (ç•«ç´  * 4)
                
                let scale = 2.0;
                if (features.upscaleMode === 2) {
                    // è¨ˆç®—é”åˆ° 1å„„ç•«ç´ æ‰€éœ€çš„å€ç‡
                    // å‡è¨­åŸåœ– 4000x3000 (12MP) -> éœ€è¦æ”¾å¤§ç´„ 2.88 å€
                    let targetMP = 100000000;
                    let currentMP = currentW * currentH;
                    scale = Math.sqrt(targetMP / currentMP);
                    maskSub.innerText = `Generating 100MP (${scale.toFixed(1)}x)...`;
                } else {
                    maskSub.innerText = "2x AI Upscale...";
                }

                let upDst = new cv.Mat();
                // Lanczos4 æ˜¯ç›®å‰éæ·±åº¦å­¸ç¿’æœ€å¥½çš„æ’å€¼ç®—æ³•
                cv.resize(dst, upDst, new cv.Size(0,0), scale, scale, cv.INTER_LANCZOS4);
                
                // æ”¾å¤§å¾Œçš„ç´°ç¯€å¢å¼· (Unsharp Masking)
                let upBlur = new cv.Mat();
                cv.GaussianBlur(upDst, upBlur, new cv.Size(0,0), 3);
                cv.addWeighted(upDst, 1.5, upBlur, -0.5, 0, upDst); // å¼·åŠ›éŠ³åŒ–

                let newC = document.createElement('canvas');
                newC.width = upDst.cols; newC.height = upDst.rows;
                cv.imshow(newC, upDst);
                cvs = newC;
                upDst.delete(); upBlur.delete();
            } else {
                cv.imshow(cvs, dst);
            }
            planes.delete(); L.delete();
        } catch(e) { console.error(e); }
        finally { src.delete(); dst.delete(); lab.delete(); }
        return cvs;
    }

    // â˜…â˜…â˜… å¼·åˆ¶ä½¿ç”¨ç¡¬é«”æ‹ç…§ï¼Œä¸æ”¯æ´ Video æˆªåœ– â˜…â˜…â˜…
    async function grabFrame() {
        if(!imageCapture) throw new Error("ImageCapture API not supported");
        
        // å–å¾—ç¡¬é«”æœ€å¤§èƒ½åŠ›
        const caps = await imageCapture.getPhotoCapabilities();
        const settings = {
            imageWidth: caps.imageWidth.max,
            imageHeight: caps.imageHeight.max
        };
        
        if(lightMode === 'flash') settings.fillLightMode = 'flash';

        try {
            const blob = await imageCapture.takePhoto(settings);
            return await createImageBitmap(blob);
        } catch(e) {
            // å¦‚æœæŒ‡å®šè§£æåº¦å¤±æ•—ï¼Œå˜—è©¦ä¸å¸¶åƒæ•¸ (è‡ªå‹•æœ€å¤§)
            const blob = await imageCapture.takePhoto();
            return await createImageBitmap(blob);
        }
    }

    async function captureHDR(count) {
        let frames = [];
        let startEv = -((count-1)/2);
        for(let i=0; i<count; i++) {
            let ev = startEv + i;
            maskSub.innerText = `HDR ${i+1}/${count}`;
            if(hwParams.exp) await videoTrack.applyConstraints({advanced:[{exposureCompensation: ev}]});
            await new Promise(r => setTimeout(r, 200)); // ç­‰å¾…æ›å…‰ç©©å®š
            frames.push(await grabFrame());
        }
        if(hwParams.exp) await videoTrack.applyConstraints({advanced:[{exposureCompensation: 0}]});
        
        // åˆæˆé‚è¼¯
        let base = frames[Math.floor(count/2)];
        if(base instanceof ImageBitmap) {
            let c = document.createElement('canvas');
            c.width = base.width; c.height = base.height;
            c.getContext('2d').drawImage(base, 0, 0);
            base = c;
        }
        let ctx = base.getContext('2d');
        ctx.globalAlpha = 0.5;
        frames.forEach((f, i) => {
            if(i !== Math.floor(count/2)) { ctx.globalCompositeOperation = 'overlay'; ctx.drawImage(f, 0, 0); }
        });
        return base;
    }

    function saveImage(c, pre) {
        const a = document.createElement('a');
        let suffix = features.upscaleMode === 2 ? "_Ultra" : (features.upscaleMode === 1 ? "_2x" : "");
        a.download = `${pre}${suffix}_${Date.now()}.jpg`;
        a.href = c.toDataURL('image/jpeg', 0.95);
        a.click();
    }

    function showMask(t) { mask.style.display = 'flex'; maskText.innerText = t; maskSub.innerText = ""; }
    function hideMask() { mask.style.display = 'none'; }

    init();
</script>
</body>
</html>


