<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>AI HDR Pro (Responsive)</title>
    <style>
        /* --- 核心佈局系統 --- */
        body { 
            margin: 0; 
            background: #000; 
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; 
            color: white; 
            /* 使用 dvh 確保在手機瀏覽器上能完美滿版 */
            height: 100dvh; 
            width: 100vw;
            overflow: hidden; 
            display: flex; 
            flex-direction: column; 
        }
        
        /* 1. 頂部工具列 (固定高度) */
        .top-bar { 
            background: rgba(20,20,30,0.95); 
            padding: 8px 15px; 
            z-index: 20;
            display: flex; 
            gap: 10px; 
            align-items: center;
            border-bottom: 1px solid #333;
            flex-shrink: 0; /* 禁止被壓縮 */
            padding-top: max(8px, env(safe-area-inset-top)); /* 避開瀏海 */
        }
        
        select { 
            flex-grow: 1; 
            background: #222; color: white; border: 1px solid #555; 
            padding: 8px; border-radius: 8px; font-size: 13px; outline: none;
            max-width: 100%;
        }

        .status-badge {
            background: #ffcc00; color: #000; padding: 4px 8px; border-radius: 4px; 
            font-size: 11px; font-weight: bold; white-space: nowrap;
        }

        /* 2. 中間預覽區 (自動填滿剩餘空間) */
        .viewport { 
            flex-grow: 1; /* 關鍵：佔據所有剩餘空間 */
            position: relative; 
            background: #000; 
            display: flex; 
            justify-content: center; 
            align-items: center; 
            overflow: hidden;
            width: 100%;
        }
        
        video { 
            width: 100%; 
            height: 100%; 
            object-fit: contain; /* 確保畫面完整顯示 */
        }

        /* HUD (狀態顯示) */
        #hud {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            display: none; flex-direction: column; align-items: center; gap: 10px; z-index: 50;
            pointer-events: none;
        }
        .spinner {
            width: 40px; height: 40px; border-radius: 50%;
            border: 4px solid rgba(255,255,255,0.1); border-top: 4px solid #ffcc00;
            animation: spin 1s infinite linear;
        }
        .hud-text {
            background: rgba(0,0,0,0.8); color: #fff; padding: 6px 12px; border-radius: 15px;
            font-size: 13px; border: 1px solid #555; text-align: center;
            white-space: nowrap;
        }
        @keyframes spin { 100% { transform: rotate(360deg); } }

        /* 3. 底部控制區 (高度適應內容) */
        .controls { 
            background: #111; 
            padding: 10px 15px 15px 15px; 
            border-top: 1px solid #333;
            display: flex; 
            flex-direction: column; 
            gap: 12px; /* 縮小間距 */
            align-items: center; 
            z-index: 20;
            flex-shrink: 0; /* 禁止被壓縮 */
            padding-bottom: max(20px, env(safe-area-inset-bottom)); /* 避開底部橫條 */
        }

        /* 曝光視覺化條 */
        .bracketing-viz {
            display: flex; gap: 4px; align-items: flex-end; height: 8px; width: 80px; justify-content: center;
            margin-bottom: -5px; /* 緊湊佈局 */
        }
        .bar { width: 18px; background: #444; border-radius: 2px; transition: 0.2s; }
        .bar.active { background: #ffcc00; box-shadow: 0 0 8px #ffcc00; }

        /* 滑桿區域 (緊湊設計) */
        .sliders-container {
            width: 100%;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .slider-row { 
            width: 100%; 
            display: flex; 
            align-items: center; 
            gap: 10px; 
            font-size: 12px; 
            font-weight: bold; 
            height: 24px;
        }
        
        .slider-label-left { width: 30px; color: #aaa; }
        .slider-label-right { width: 35px; text-align: right; font-family: monospace; }
        
        /* 不同的顏色區分功能 */
        .zoom-text { color: #ffd700; }
        .ev-text { color: #00d2ff; }
        
        input[type=range] { 
            flex-grow: 1; height: 4px; border-radius: 2px; cursor: pointer;
            -webkit-appearance: none; background: #444;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none; width: 18px; height: 18px; border-radius: 50%; background: #fff;
            box-shadow: 0 0 5px rgba(0,0,0,0.5);
        }
        input[type=range].zoom-range { accent-color: #ffd700; }
        input[type=range].ev-range { accent-color: #00d2ff; }

        /* 快門按鈕 */
        .shutter-btn {
            width: 64px; height: 64px; /* 稍微縮小以適應小螢幕 */
            border-radius: 50%;
            border: 4px solid rgba(255,255,255,0.3);
            background: radial-gradient(circle, #fff 30%, #ffcc00 100%);
            cursor: pointer; position: relative; transition: 0.1s;
            box-shadow: 0 0 15px rgba(255, 200, 0, 0.2);
            flex-shrink: 0;
        }
        .shutter-btn:active { transform: scale(0.92); }

        canvas { display: none; }
    </style>
</head>
<body>

    <!-- 濾鏡 SVG -->
    <svg style="width:0;height:0;position:absolute;">
        <defs><filter id="smart-sharpen"><feConvolveMatrix order="3" kernelMatrix="0 -1 0 -1 5 -1 0 -1 0"/></filter></defs>
    </svg>

    <!-- 頂部 -->
    <div class="top-bar">
        <select id="cameraSelect"><option>Loading...</option></select>
        <div id="resInfo" class="status-badge">Init...</div>
    </div>

    <!-- 中間 (自動伸縮) -->
    <div class="viewport">
        <video id="videoPreview" autoplay playsinline muted></video>
        
        <div id="hud">
            <div class="spinner"></div>
            <div class="hud-text">
                <div id="hud-status">HDR 初始化...</div>
                <div id="hud-ev" style="color:#ffcc00; font-weight:bold;">EV 0</div>
            </div>
        </div>
    </div>

    <!-- 底部 (固定不跑版) -->
    <div class="controls">
        <div class="bracketing-viz">
            <div class="bar" style="height: 60%" id="bar-low"></div>
            <div class="bar" style="height: 100%" id="bar-mid"></div>
            <div class="bar" style="height: 60%" id="bar-high"></div>
        </div>

        <div class="sliders-container">
            <!-- EV 滑桿 -->
            <div class="slider-row">
                <span class="slider-label-left ev-text">EV±</span>
                <input type="range" class="ev-range" id="evSlider" min="0.5" max="3.0" step="0.5" value="2.0">
                <span id="evDisplay" class="slider-label-right ev-text">2.0</span>
            </div>

            <!-- Zoom 滑桿 -->
            <div class="slider-row">
                <span class="slider-label-left zoom-text">Mag</span>
                <input type="range" class="zoom-range" id="zoomSlider" min="1" max="8" step="0.1" value="1" disabled>
                <span id="zoomVal" class="slider-label-right zoom-text">1.0</span>
            </div>
        </div>

        <div class="shutter-btn" onclick="captureHDR()"></div>
    </div>

    <!-- 處理用畫布 -->
    <canvas id="canvasLow"></canvas>
    <canvas id="canvasMid"></canvas>
    <canvas id="canvasHigh"></canvas>
    <canvas id="thumbCanvas" width="64" height="64"></canvas>

<script>
    const video = document.getElementById('videoPreview');
    const cameraSelect = document.getElementById('cameraSelect');
    const zoomSlider = document.getElementById('zoomSlider');
    const evSlider = document.getElementById('evSlider');
    const resInfo = document.getElementById('resInfo');
    const hud = document.getElementById('hud');
    const hudStatus = document.getElementById('hud-status');
    const hudEv = document.getElementById('hud-ev');
    
    // 視覺化條
    const barLow = document.getElementById('bar-low');
    const barMid = document.getElementById('bar-mid');
    const barHigh = document.getElementById('bar-high');

    let currentStream, videoTrack, imageCapture;
    let hardwareExposure = false;
    let maxExposureRange = 2; // 預設最大 EV 範圍

    // 1. 初始化並列出鏡頭
    async function init() {
        try {
            const stream = await navigator.mediaDevices.getUserMedia({ video: true });
            stream.getTracks().forEach(t => t.stop());
            const devices = await navigator.mediaDevices.enumerateDevices();
            const cams = devices.filter(d => d.kind === 'videoinput');
            
            cameraSelect.innerHTML = '';
            cams.forEach((d, i) => {
                const opt = document.createElement('option');
                opt.value = d.deviceId;
                opt.text = d.label || `鏡頭 ${i}`;
                cameraSelect.appendChild(opt);
            });

            if(cams.length > 0) {
                const def = cams[cams.length - 1];
                cameraSelect.value = def.deviceId;
                startCamera(def.deviceId);
            }
            cameraSelect.onchange = (e) => startCamera(e.target.value);
        } catch(e) { alert("請允許相機權限"); }
    }

    // 2. 啟動特定鏡頭
    async function startCamera(id) {
        if(currentStream) currentStream.getTracks().forEach(t => t.stop());
        zoomSlider.disabled = true;

        try {
            await launchStream({ video: { deviceId: { exact: id }, width: { ideal: 4096 }, height: { ideal: 4096 } } });
        } catch(e) {
            try { 
                await launchStream({ video: { deviceId: { exact: id } } });
            } catch(e2) { alert("此鏡頭無法啟動"); }
        }
    }

    async function launchStream(constraints) {
        const stream = await navigator.mediaDevices.getUserMedia(constraints);
        currentStream = stream;
        video.srcObject = stream;
        videoTrack = stream.getVideoTracks()[0];
        if(window.ImageCapture) try{imageCapture = new ImageCapture(videoTrack)}catch(e){}

        video.onloadedmetadata = () => {
            const caps = videoTrack.getCapabilities ? videoTrack.getCapabilities() : {};
            
            // 設定變焦
            if(caps.zoom) {
                zoomSlider.disabled = false;
                zoomSlider.min = caps.zoom.min;
                zoomSlider.max = Math.min(caps.zoom.max, 8);
                zoomSlider.step = 0.1;
                zoomSlider.value = 1;
                zoomSlider.oninput = function() {
                    document.getElementById('zoomVal').innerText = parseFloat(this.value).toFixed(1);
                    videoTrack.applyConstraints({advanced:[{zoom:this.value}]});
                }
            }

            // 檢查並設定硬體 EV
            if(caps.exposureCompensation) {
                hardwareExposure = true;
                resInfo.innerText = "HDR Pro";
                resInfo.style.background = "#ffcc00";
                
                const maxEV = caps.exposureCompensation.max;
                const minEV = caps.exposureCompensation.min;
                maxExposureRange = Math.min(Math.abs(maxEV), Math.abs(minEV));
                evSlider.max = maxExposureRange;
                evSlider.value = Math.min(2.0, maxExposureRange);
                document.getElementById('evDisplay').innerText = parseFloat(evSlider.value).toFixed(1);
            } else {
                hardwareExposure = false;
                resInfo.innerText = "HDR Sim";
                resInfo.style.background = "#666";
                evSlider.disabled = true; 
            }
        };
    }
    
    evSlider.oninput = function() {
        document.getElementById('evDisplay').innerText = parseFloat(this.value).toFixed(1);
    }

    async function setEV(value) {
        if (!hardwareExposure) return;
        try {
            let safeValue = Math.max(-maxExposureRange, Math.min(value, maxExposureRange));
            await videoTrack.applyConstraints({ advanced: [{ exposureCompensation: safeValue }] });
            await new Promise(r => setTimeout(r, 200)); 
        } catch(e) {}
    }

    // 3. HDR 拍攝流程
    async function captureHDR() {
        hud.style.display = 'flex';
        const framesLow = [], framesMid = [], framesHigh = [];
        const range = parseFloat(evSlider.value);

        try {
            // A. 抓高光
            updateHUD("鎖定高光", `EV -${range}`, "low");
            await setEV(-range);
            for(let i=0; i<3; i++) framesLow.push(await grab());

            // B. 抓陰影
            updateHUD("捕捉暗部", `EV +${range}`, "high");
            await setEV(range);
            for(let i=0; i<3; i++) framesHigh.push(await grab());

            // C. 抓基準
            updateHUD("建立基準", "EV 0.0", "mid");
            await setEV(0);
            for(let i=0; i<6; i++) framesMid.push(await grab());

            // D. 運算融合
            updateHUD("AI 融合運算", "Processing", "all");
            
            const cvsLow = await stackImages(framesLow, "canvasLow");
            const cvsHigh = await stackImages(framesHigh, "canvasHigh");
            const cvsMid = await stackImages(framesMid, "canvasMid");

            const ctx = cvsMid.getContext('2d');
            
            // Screen 提亮暗部
            ctx.globalCompositeOperation = 'screen';
            ctx.globalAlpha = 0.5;
            ctx.drawImage(cvsHigh, 0, 0);

            // Soft-light 壓制高光
            ctx.globalCompositeOperation = 'soft-light';
            ctx.globalAlpha = 0.6;
            ctx.drawImage(cvsLow, 0, 0);

            // 恢復與銳化
            ctx.globalCompositeOperation = 'source-over';
            ctx.globalAlpha = 1.0;
            
            const temp = document.createElement('canvas');
            temp.width = cvsMid.width; temp.height = cvsMid.height;
            temp.getContext('2d').drawImage(cvsMid, 0, 0);
            
            ctx.filter = 'url(#smart-sharpen) contrast(1.1) saturate(1.15)';
            ctx.clearRect(0,0,cvsMid.width,cvsMid.height);
            ctx.drawImage(temp, 0, 0);
            ctx.filter = 'none';

            save(cvsMid);

        } catch(e) {
            console.error(e);
            alert("拍攝失敗");
            if(framesMid.length > 0) save(framesMid[0]);
        } finally {
            hud.style.display = 'none';
            setEV(0);
            resetBars();
        }
    }

    async function stackImages(frames, canvasId) {
        const canvas = document.getElementById(canvasId);
        canvas.width = frames[0].width; canvas.height = frames[0].height;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(frames[0], 0, 0);
        
        let count = 1;
        for(let i=1; i<frames.length; i++) {
            const diff = getDiff(frames[0], frames[i]);
            if(diff < 50) { 
                ctx.globalAlpha = 1 / (count + 1);
                ctx.drawImage(frames[i], 0, 0);
                count++;
                ctx.globalAlpha = 1.0;
            }
        }
        return canvas;
    }

    async function grab() {
        if(imageCapture) {
            try { return await imageCapture.grabFrame(); } catch(e){}
        }
        const c = document.createElement('canvas');
        c.width = video.videoWidth; c.height = video.videoHeight;
        c.getContext('2d').drawImage(video,0,0);
        return c;
    }

    function getDiff(img1, img2) {
        const tCtx = document.getElementById('thumbCanvas').getContext('2d');
        tCtx.drawImage(img1, 0, 0, 64, 64);
        const d1 = tCtx.getImageData(0,0,64,64).data;
        tCtx.clearRect(0,0,64,64);
        tCtx.drawImage(img2, 0, 0, 64, 64);
        const d2 = tCtx.getImageData(0,0,64,64).data;
        let diff = 0;
        for(let i=0; i<d1.length; i+=16) diff += Math.abs(d1[i] - d2[i]);
        return diff / (64*64/4);
    }

    function updateHUD(status, ev, bar) {
        hudStatus.innerText = status;
        hudEv.innerText = ev;
        resetBars();
        if(bar === 'all') { barLow.classList.add('active'); barMid.classList.add('active'); barHigh.classList.add('active'); }
        else document.getElementById(`bar-${bar}`).classList.add('active');
    }

    function resetBars() {
        document.querySelectorAll('.bar').forEach(b => b.classList.remove('active'));
    }

    function save(canvas) {
        const link = document.createElement('a');
        link.download = `HDR_Pro_${Date.now()}.jpg`;
        link.href = canvas.toDataURL('image/jpeg', 0.95);
        link.click();
    }

    init();
</script>
</body>
</html>

