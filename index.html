<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>AI Tracking Cam</title>
    <style>
        body { margin: 0; background: #000; font-family: -apple-system, Roboto, sans-serif; color: white; height: 100dvh; display: flex; flex-direction: column; overflow: hidden; }
        
        /* È†ÇÈÉ® */
        .top-bar { 
            background: rgba(20,20,25,0.95); padding: 8px 12px; z-index: 20;
            display: flex; flex-direction: column; gap: 8px; border-bottom: 1px solid #333;
            padding-top: max(10px, env(safe-area-inset-top));
        }
        
        .row { display: flex; justify-content: space-between; align-items: center; width: 100%; gap: 8px; }
        
        select { background: #222; color: #fff; border: 1px solid #555; padding: 6px; border-radius: 6px; font-size: 13px; flex-grow: 1; max-width: 120px; }
        
        .toggle-btn {
            background: #222; border: 1px solid #444; color: #aaa; padding: 4px 8px; border-radius: 12px; font-size: 11px; cursor: pointer; display: flex; align-items: center; gap: 4px; white-space: nowrap;
        }
        .toggle-btn input { margin: 0; }
        .toggle-btn.active { border-color: #00d2ff; color: #00d2ff; font-weight: bold; }

        /* ÁáàÂÖâÊéßÂà∂ */
        .light-group { display: flex; background: #222; border-radius: 8px; border: 1px solid #444; padding: 2px; }
        .light-btn { padding: 5px 10px; font-size: 14px; cursor: pointer; border-radius: 6px; border: none; background: transparent; color: #666; transition: 0.2s; }
        .light-btn.active { background: #ffd700; color: #000; font-weight: bold; box-shadow: 0 0 10px rgba(255, 215, 0, 0.4); }
        
        /* Ë¶ñÁ™ó */
        .viewport { 
            flex-grow: 1; position: relative; background: #111; overflow: hidden;
            display: flex; justify-content: center; align-items: center; 
        }
        video { width: 100%; height: 100%; object-fit: contain; }

        /* ËøΩËπ§Ê°Ü (Target Reticle) */
        #tracker-box {
            position: absolute; width: 80px; height: 80px;
            border: 2px solid #00ff00; border-radius: 8px;
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.5);
            display: none; pointer-events: none; transition: all 0.1s linear;
            z-index: 10;
        }
        #tracker-box::before, #tracker-box::after {
            content: ''; position: absolute; background: #00ff00;
        }
        /* ÂçÅÂ≠óÊ∫ñÂøÉ */
        #tracker-box::before { top: 50%; left: 20%; right: 20%; height: 1px; }
        #tracker-box::after { left: 50%; top: 20%; bottom: 20%; width: 1px; }

        #status-pill {
            position: absolute; top: 15px; left: 15px;
            background: rgba(0,0,0,0.6); padding: 4px 10px; border-radius: 15px;
            font-size: 11px; color: #00ff88; border: 1px solid rgba(0,255,136,0.3); pointer-events: none; z-index: 10;
        }
        .warn-mode { color: #ffd700 !important; border-color: #ffd700 !important; }

        /* ÊãçÊîùÈÅÆÁΩ© */
        #mask {
            position: absolute; inset: 0; background: rgba(0,0,0,0.9); z-index: 50;
            display: none; justify-content: center; align-items: center; flex-direction: column; gap: 15px;
        }
        .spinner {
            width: 40px; height: 40px; border-radius: 50%;
            border: 3px solid #333; border-top: 3px solid #00d2ff;
            animation: spin 1s infinite linear;
        }
        
        /* Â∫ïÈÉ® */
        .controls { 
            background: #111; padding: 10px 15px; flex-shrink: 0; z-index: 20;
            border-top: 1px solid #333; display: grid; grid-template-columns: 1fr 60px; gap: 10px;
            padding-bottom: max(20px, env(safe-area-inset-bottom));
        }

        .sliders-col { display: flex; flex-direction: column; gap: 10px; }
        .slider-row { width: 100%; display: flex; align-items: center; gap: 8px; font-size: 11px; font-weight: bold; color: #aaa; }
        .label { width: 35px; text-align: right; }
        .value-disp { width: 30px; text-align: right; font-family: monospace; }
        
        input[type=range] { flex-grow: 1; height: 4px; border-radius: 2px; -webkit-appearance: none; background: #444; }
        input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; width: 16px; height: 16px; border-radius: 50%; background: #fff; }
        
        .ac-iso input { accent-color: #ff0055; }
        .ac-focus input { accent-color: #ffff00; }
        .ac-ev input { accent-color: #00d2ff; }
        .ac-zoom input { accent-color: #00ff88; }

        /* AF/MF/Track ÊåâÈàï */
        .af-btn {
            background: #333; color: #fff; border: 1px solid #555; padding: 2px 6px; border-radius: 4px; font-size: 10px; cursor: pointer; width: 35px; text-align: center;
        }
        .af-btn.tracking { background: #00ff00; color: #000; font-weight: bold; border-color: #fff; animation: pulse 2s infinite; }
        .af-btn.manual { background: #ffff00; color: #000; font-weight: bold; }

        @keyframes pulse { 0% {box-shadow: 0 0 0 0 rgba(0, 255, 0, 0.7);} 70% {box-shadow: 0 0 0 5px rgba(0, 255, 0, 0);} 100% {box-shadow: 0 0 0 0 rgba(0, 255, 0, 0);} }

        .shutter-col { display: flex; align-items: center; justify-content: center; }
        .shutter {
            width: 64px; height: 64px; border-radius: 50%;
            border: 4px solid rgba(255,255,255,0.3);
            background: radial-gradient(circle, #fff 30%, #00d2ff 100%);
            cursor: pointer; transition: 0.1s; position: relative;
            box-shadow: 0 0 15px rgba(0, 210, 255, 0.3);
        }
        .shutter:active { transform: scale(0.95); }

        @keyframes spin { 100% { transform: rotate(360deg); } }
        canvas { display: none; }
    </style>
</head>
<body>

    <svg style="width:0;height:0;position:absolute;">
        <defs>
            <filter id="smart-sharpen"><feConvolveMatrix order="3" kernelMatrix="0 -1 0 -1 5 -1 0 -1 0"/></filter>
            <filter id="upscale-sharpen"><feConvolveMatrix order="3" kernelMatrix="0 -0.5 0 -0.5 3 -0.5 0 -0.5 0"/></filter>
            <filter id="soft-denoise">
                <feGaussianBlur in="SourceGraphic" stdDeviation="1.5" result="blur"/>
                <feComposite in="SourceGraphic" in2="blur" operator="arithmetic" k1="0" k2="0.6" k3="0.4" k4="0"/>
            </filter>
        </defs>
    </svg>

    <div class="top-bar">
        <div class="row">
            <select id="cameraSelect"><option>Loading...</option></select>
            <div class="light-group">
                <button class="light-btn active" id="light-off" onclick="setLightMode('off')">üö´</button>
                <button class="light-btn" id="light-flash" onclick="setLightMode('flash')">‚ö°</button>
                <button class="light-btn" id="light-torch" onclick="setLightMode('torch')">üî¶</button>
            </div>
        </div>
        <div class="row" style="justify-content: flex-start; gap: 5px; flex-wrap: wrap;">
            <select id="hdrCount" style="max-width: 50px;">
                <option value="3">3x</option>
                <option value="5">5x</option>
                <option value="7">7x</option>
            </select>
            <label class="toggle-btn active" id="hdrBtn">
                <input type="checkbox" id="hdrToggle" checked onchange="toggleStyle(this, 'hdrBtn')"> HDR
            </label>
            <label class="toggle-btn" id="upscaleBtn">
                <input type="checkbox" id="upscaleToggle" onchange="toggleStyle(this, 'upscaleBtn')"> 2x AI
            </label>
            <label class="toggle-btn" id="denoiseBtn">
                <input type="checkbox" id="denoiseToggle" onchange="toggleStyle(this, 'denoiseBtn')"> ÈôçÂô™
            </label>
            <label class="toggle-btn" id="rawBtn">
                <input type="checkbox" id="rawToggle" onchange="toggleStyle(this, 'rawBtn')"> PNG
            </label>
        </div>
    </div>

    <div class="viewport">
        <video id="videoPreview" autoplay playsinline muted></video>
        <div id="status-pill">Init...</div>
        
        <!-- ËøΩËπ§Â∞çÁÑ¶Ê°Ü -->
        <div id="tracker-box"></div>

        <div id="mask">
            <div class="spinner"></div>
            <div id="mask-text" style="color:#00d2ff; font-family:monospace;">Processing...</div>
        </div>
    </div>

    <div class="controls">
        <div class="sliders-col">
            <!-- 1. ISO -->
            <div class="slider-row ac-iso">
                <span class="label">ISO</span>
                <input type="range" id="isoSlider" min="100" max="3200" step="100" value="100">
                <span id="isoText" class="value-disp">Auto</span>
            </div>
            
            <!-- 2. Focus + Tracking (Êñ∞ÂäüËÉΩ) -->
            <div class="slider-row ac-focus">
                <span class="label">Â∞çÁÑ¶</span>
                <input type="range" id="focusSlider" min="0" max="100" step="1" value="0" disabled>
                <div id="afBtn" class="af-btn" onclick="cycleFocusMode()">AF</div>
            </div>

            <!-- 3. EV -->
            <div class="slider-row ac-ev">
                <span class="label">EV</span>
                <input type="range" id="evRange" min="-3" max="3" step="0.5" value="0">
                <span id="evText" class="value-disp">0</span>
            </div>

            <!-- 4. Zoom -->
            <div class="slider-row ac-zoom">
                <span class="label">Zoom</span>
                <input type="range" id="zoomSlider" min="1" max="8" step="0.1" value="1" disabled>
                <span id="zoomText" class="value-disp">1.0</span>
            </div>
        </div>

        <div class="shutter-col">
            <div class="shutter" onclick="capture()"></div>
        </div>
    </div>

    <canvas id="cFinal"></canvas>
    <canvas id="cUpscale"></canvas>
    <!-- ÂàÜÊûêÁî®Â∞èÁï´Â∏É (Âãï‰ΩúÂÅµÊ∏¨) -->
    <canvas id="cMotion" width="64" height="64"></canvas>

<script>
    const video = document.getElementById('videoPreview');
    const statusPill = document.getElementById('status-pill');
    const mask = document.getElementById('mask');
    const maskText = document.getElementById('mask-text');
    const cameraSelect = document.getElementById('cameraSelect');
    
    // Controls
    const isoSlider = document.getElementById('isoSlider');
    const focusSlider = document.getElementById('focusSlider');
    const afBtn = document.getElementById('afBtn');
    const trackerBox = document.getElementById('tracker-box');
    
    let currentStream, videoTrack, imageCapture;
    let hardwareExposure = false;
    let hardwareIso = false;
    let hardwareFocus = false;
    let isSafeMode = false;
    let softwareGain = 1.0; 
    let currentLightMode = 'off'; 
    let hasTorch = false;

    // Â∞çÁÑ¶Ê®°Âºè: 'af' (Ëá™Âãï), 'mf' (ÊâãÂãï), 'track' (ËøΩËπ§)
    let focusModeState = 'af';
    let trackingInterval;
    let prevFrameData = null;

    async function init() {
        try {
            const stream = await navigator.mediaDevices.getUserMedia({ video: true });
            stream.getTracks().forEach(t => t.stop());
            
            const devices = await navigator.mediaDevices.enumerateDevices();
            const cams = devices.filter(d => d.kind === 'videoinput');
            
            cameraSelect.innerHTML = '';
            cams.forEach((d, i) => {
                const opt = document.createElement('option');
                opt.value = d.deviceId;
                opt.text = d.label || `Camera ${i} (ID:${i})`;
                opt.dataset.index = i;
                cameraSelect.appendChild(opt);
            });

            if(cams.length > 0) {
                const lastIdx = cams.length - 1;
                cameraSelect.selectedIndex = lastIdx;
                switchCamera(cams[lastIdx].deviceId, lastIdx);
            }
            cameraSelect.onchange = e => {
                const idx = parseInt(e.target.selectedOptions[0].dataset.index);
                switchCamera(e.target.value, idx);
            };
        } catch(e) { alert("Ë´ãÂÖÅË®±Áõ∏Ê©üÊ¨äÈôê"); }
    }

    async function switchCamera(id, index) {
        setLightMode('off');
        stopTracking(); // ÂàáÊèõÈè°È†≠ÊôÇÂÅúÊ≠¢ËøΩËπ§
        
        if(currentStream) currentStream.getTracks().forEach(t => t.stop());
        statusPill.innerText = "ÂàáÊèõ‰∏≠...";
        isSafeMode = false;

        try {
            if (index === 2) { 
                await launch({ video: { deviceId: { exact: id }, width: { ideal: 640 }, height: { ideal: 480 } } }, "Wide/VGA");
                isSafeMode = true; 
            } else {
                await launch({ video: { deviceId: { exact: id }, width: { ideal: 4096 }, height: { ideal: 4096 }, aspectRatio: 1.333 } }, "4K");
            }
        } catch(e1) {
            try {
                await launch({ video: { deviceId: { exact: id }, width: { ideal: 640 }, height: { ideal: 480 } } }, "SafeMode");
                isSafeMode = true; 
            } catch(e2) {
                statusPill.innerText = "Error";
                alert("ÁÑ°Ê≥ïÂïüÂãï");
            }
        }
    }

    async function launch(constraints, label) {
        const stream = await navigator.mediaDevices.getUserMedia(constraints);
        currentStream = stream;
        video.srcObject = stream;
        videoTrack = stream.getVideoTracks()[0];
        
        if(window.ImageCapture) {
            try { imageCapture = new ImageCapture(videoTrack); } catch(e){}
        }

        const caps = videoTrack.getCapabilities ? videoTrack.getCapabilities() : {};
        
        // Torch
        hasTorch = !!caps.torch;
        document.getElementById('light-torch').disabled = !hasTorch;

        // Zoom
        const zs = document.getElementById('zoomSlider');
        if(caps.zoom) {
            zs.disabled = false;
            zs.min = caps.zoom.min;
            zs.max = Math.min(caps.zoom.max, 8);
            zs.value = 1;
            zs.oninput = function() { 
                document.getElementById('zoomText').innerText = parseFloat(this.value).toFixed(1);
                videoTrack.applyConstraints({advanced:[{zoom:this.value}]}); 
            }
        } else { zs.disabled = true; }

        // ISO
        hardwareIso = !!caps.iso;
        isoSlider.min = hardwareIso ? caps.iso.min : 100;
        isoSlider.max = hardwareIso ? caps.iso.max : 3200;
        isoSlider.value = isoSlider.min;
        document.getElementById('isoText').innerText = "Auto";
        softwareGain = 1.0;
        video.style.filter = "none";

        isoSlider.oninput = function() {
            const val = parseInt(this.value);
            document.getElementById('isoText').innerText = val;
            softwareGain = 1.0 + ((val - 100) / 1000);
            video.style.filter = `brightness(${softwareGain})`;
            if(hardwareIso) videoTrack.applyConstraints({ advanced: [{ iso: val }] }).catch(()=>{});
        };

        // Focus & Tracking Capability
        hardwareFocus = caps.focusMode && caps.focusMode.includes('manual');
        resetFocusUI();

        hardwareExposure = !!caps.exposureCompensation;
        
        video.onloadedmetadata = () => {
            statusPill.innerText = label;
            if(isSafeMode) statusPill.classList.add("warn-mode");
            else statusPill.classList.remove("warn-mode");
        };
    }

    // ‚òÖ‚òÖ‚òÖ ÁÑ¶ÈªûÊ®°ÂºèÂæ™Áí∞ (AF -> MF -> Track) ‚òÖ‚òÖ‚òÖ
    function cycleFocusMode() {
        if(focusModeState === 'af') {
            // ÂàáÊèõÂà∞ÊâãÂãï (MF)
            if(hardwareFocus) {
                focusModeState = 'mf';
                afBtn.innerText = "MF";
                afBtn.className = "af-btn manual";
                focusSlider.disabled = false;
                videoTrack.applyConstraints({ advanced: [{ focusMode: 'manual' }] });
            } else {
                // Â¶ÇÊûú‰∏çÊîØÊè¥ÊâãÂãïÔºåÁõ¥Êé•Ë∑≥Âà∞ËøΩËπ§
                startTrackingMode();
            }
        } else if(focusModeState === 'mf') {
            // ÂàáÊèõÂà∞ËøΩËπ§ (Track)
            startTrackingMode();
        } else {
            // ÂàáÊèõÂõûËá™Âãï (AF)
            stopTracking();
            focusModeState = 'af';
            afBtn.innerText = "AF";
            afBtn.className = "af-btn";
            focusSlider.disabled = true;
            videoTrack.applyConstraints({ advanced: [{ focusMode: 'continuous' }] });
        }
    }

    function resetFocusUI() {
        stopTracking();
        focusModeState = 'af';
        afBtn.innerText = "AF";
        afBtn.className = "af-btn";
        afBtn.style.opacity = "1";
        focusSlider.disabled = true;
    }

    // ÊâãÂãïÂ∞çÁÑ¶ÊéßÂà∂
    focusSlider.oninput = function() {
        if(focusModeState === 'mf') {
            const val = parseInt(this.value) / 100; // 0.0 - 1.0
            videoTrack.applyConstraints({ advanced: [{ focusDistance: val }] });
        }
    }

    // ‚òÖ‚òÖ‚òÖ ËøΩËπ§Â∞çÁÑ¶Á≥ªÁµ± ‚òÖ‚òÖ‚òÖ
    function startTrackingMode() {
        focusModeState = 'track';
        afBtn.innerText = "üéØ";
        afBtn.className = "af-btn tracking";
        focusSlider.disabled = true;
        trackerBox.style.display = 'block';
        
        // ËøΩËπ§Ê®°Âºè‰∏ãÔºåÂº∑Âà∂ÈñãÂïüÈÄ£Á∫åÂ∞çÁÑ¶ÔºåËÆìÁ°¨È´îÂéªË∑ü
        videoTrack.applyConstraints({ advanced: [{ focusMode: 'continuous' }] }).catch(()=>{});

        // ÂïüÂãïË¶ñË¶∫ËøΩËπ§ÈÅãÁÆó
        if(trackingInterval) clearInterval(trackingInterval);
        const cvs = document.getElementById('cMotion');
        const ctx = cvs.getContext('2d');
        prevFrameData = null;

        trackingInterval = setInterval(() => {
            if(video.readyState !== 4) return;
            
            // 1. ÊäìÁ∏ÆÂúñ (64x64)
            ctx.drawImage(video, 0, 0, 64, 64);
            const frame = ctx.getImageData(0, 0, 64, 64);
            const data = frame.data;

            if(prevFrameData) {
                let maxDiff = 0;
                let avgX = 0, avgY = 0, count = 0;

                // 2. Â∑ÆÁï∞ÊØîÂ∞ç (Motion Detection)
                for(let i=0; i<data.length; i+=16) { // Âø´ÈÄüÊé°Ê®£
                    const diff = Math.abs(data[i] - prevFrameData[i]) + 
                                 Math.abs(data[i+1] - prevFrameData[i+1]) +
                                 Math.abs(data[i+2] - prevFrameData[i+2]);
                    
                    if(diff > 30) { // ÈñæÂÄº: Ë¶ñÁÇ∫ÁßªÂãï
                        const idx = i / 4;
                        const x = idx % 64;
                        const y = Math.floor(idx / 64);
                        avgX += x;
                        avgY += y;
                        count++;
                    }
                }

                // 3. Êõ¥Êñ∞ËøΩËπ§Ê°Ü‰ΩçÁΩÆ (Center of Motion)
                if(count > 5) { // ÊúâË∂≥Â§†Â§öÁöÑÁßªÂãïÈªû
                    const cx = (avgX / count) / 64 * 100; // ËΩâÁÇ∫ %
                    const cy = (avgY / count) / 64 * 100;
                    
                    // Âπ≥ÊªëÁßªÂãï (Lerp)
                    trackerBox.style.left = `calc(${cx}% - 40px)`;
                    trackerBox.style.top = `calc(${cy}% - 40px)`;
                    trackerBox.style.borderColor = "#00ff00"; // ÈéñÂÆöÁ∂†Ëâ≤
                } else {
                    trackerBox.style.borderColor = "#555"; // ÈùúÊ≠¢ÁÅ∞Ëâ≤
                }
            }
            prevFrameData = data;
        }, 100); // 10fps ÂÅµÊ∏¨
    }

    function stopTracking() {
        if(trackingInterval) clearInterval(trackingInterval);
        trackerBox.style.display = 'none';
        prevFrameData = null;
    }

    // ‚òÖ‚òÖ‚òÖ ÁáàÂÖâÊéßÂà∂ ‚òÖ‚òÖ‚òÖ
    window.setLightMode = async function(mode) {
        if(!videoTrack) return;
        document.querySelectorAll('.light-btn').forEach(b => b.classList.remove('active'));
        document.getElementById(`light-${mode}`).classList.add('active');
        currentLightMode = mode;

        try {
            if (mode === 'torch') {
                await videoTrack.applyConstraints({ advanced: [{ torch: true }] });
            } else {
                if (hasTorch) await videoTrack.applyConstraints({ advanced: [{ torch: false }] });
            }
        } catch(e) {}
    }

    // ÊãçÊîùËàáÂêàÊàê (‰øùÁïô‰πãÂâçÁöÑÂÆåÊï¥ÂäüËÉΩ)
    async function capture() {
        mask.style.display = 'flex';
        const isHdr = document.getElementById('hdrToggle').checked;
        
        try {
            if(!isHdr) {
                maskText.innerText = "Capturing...";
                const opts = (currentLightMode === 'flash') ? {fillLightMode: 'flash'} : {};
                const bmp = await grabHighQuality(true, opts); 
                await finalize(bmp, "Photo");
            } else {
                const count = parseInt(document.getElementById('hdrCount').value);
                const frames = [];
                const startEv = -((count-1)/2); 
                const useSlowPath = isSafeMode; 

                for(let i=0; i<count; i++) {
                    const ev = startEv + i;
                    maskText.innerText = `HDR ${i+1}/${count}`;
                    await setEV(ev);
                    await sleep(useSlowPath ? 400 : 150); 
                    const bmp = await grabHighQuality(useSlowPath); 
                    frames.push({ ev: ev, img: bmp });
                }
                await setEV(0);
                maskText.innerText = "Merging...";
                await processHDR(frames);
            }
        } catch(e) {
            alert("Error: " + e.message);
            mask.style.display = 'none';
        }
    }

    async function grabHighQuality(forceTakePhoto = false, opts={}) {
        if(imageCapture && (forceTakePhoto || true)) { 
            try {
                const blob = await imageCapture.takePhoto(opts);
                return await createImageBitmap(blob);
            } catch(e) {}
        }
        const c = document.createElement('canvas');
        c.width = video.videoWidth; c.height = video.videoHeight;
        c.getContext('2d').drawImage(video, 0, 0);
        return c;
    }

    async function processHDR(frames) {
        const base = frames[Math.floor(frames.length / 2)];
        const canvas = document.getElementById('cFinal');
        canvas.width = base.img.width; canvas.height = base.img.height;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(base.img, 0, 0);
        ctx.globalAlpha = 0.5; 
        frames.forEach(f => {
            if(f.ev < 0) { ctx.globalCompositeOperation = 'darken'; ctx.drawImage(f.img, 0, 0); } 
            else if(f.ev > 0) { ctx.globalCompositeOperation = 'lighten'; ctx.drawImage(f.img, 0, 0); }
        });
        ctx.globalCompositeOperation = 'source-over';
        ctx.globalAlpha = 1.0;
        applyFilter(ctx, 'url(#smart-sharpen) contrast(1.1)');
        await finalize(canvas, "HDR");
    }

    async function finalize(source, prefix) {
        const isUpscale = document.getElementById('upscaleToggle').checked;
        const isDenoise = document.getElementById('denoiseToggle').checked;
        const isPng = document.getElementById('rawToggle').checked;
        
        let canvas = document.getElementById('cFinal');
        if(source instanceof ImageBitmap || source instanceof HTMLVideoElement) {
            canvas.width = source.width; canvas.height = source.height;
            canvas.getContext('2d').drawImage(source, 0, 0);
        } else { canvas = source; }

        const ctx = canvas.getContext('2d');
        if (softwareGain > 1.0) {
            const t = document.createElement('canvas'); t.width=canvas.width; t.height=canvas.height;
            t.getContext('2d').drawImage(canvas, 0, 0);
            ctx.filter = `brightness(${softwareGain})`;
            ctx.clearRect(0,0,canvas.width,canvas.height);
            ctx.drawImage(t, 0, 0);
            ctx.filter = 'none';
        }
        if(isDenoise) applyFilter(ctx, 'url(#soft-denoise)');

        if(isUpscale && canvas.width * canvas.height < 20000000) {
            maskText.innerText = "Upscaling...";
            const upCvs = document.getElementById('cUpscale');
            upCvs.width = canvas.width * 2; upCvs.height = canvas.height * 2;
            const uCtx = upCvs.getContext('2d');
            uCtx.imageSmoothingEnabled = true;
            uCtx.imageSmoothingQuality = 'high';
            uCtx.drawImage(canvas, 0, 0, upCvs.width, upCvs.height);
            applyFilter(uCtx, 'url(#upscale-sharpen)');
            canvas = upCvs;
        }

        const link = document.createElement('a');
        link.download = `${prefix}_${Date.now()}.${isPng ? 'png' : 'jpg'}`;
        link.href = canvas.toDataURL(isPng ? 'image/png' : 'image/jpeg', 0.95);
        link.click();
        mask.style.display = 'none';
    }

    async function setEV(val) { if(hardwareExposure) try{await videoTrack.applyConstraints({advanced:[{exposureCompensation:val}]})}catch(e){} }
    function applyFilter(ctx, filter) {
        const t = document.createElement('canvas'); t.width=ctx.canvas.width; t.height=ctx.canvas.height;
        t.getContext('2d').drawImage(ctx.canvas,0,0);
        ctx.filter = filter;
        ctx.clearRect(0,0,t.width,t.height);
        ctx.drawImage(t,0,0);
        ctx.filter = 'none';
    }
    function toggleStyle(el, labelId) { document.getElementById(labelId).classList.toggle('active', el.checked); }
    document.getElementById('evRange').oninput = function() { 
        document.getElementById('evText').innerText = this.value;
        setEV(parseFloat(this.value));
    };
    function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

    init();
</script>
</body>
</html>

