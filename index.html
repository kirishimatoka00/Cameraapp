<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>AI Adaptive HDR Camera</title>
    <style>
        body { margin: 0; background: #000; font-family: -apple-system, sans-serif; color: white; height: 100dvh; display: flex; flex-direction: column; overflow: hidden; }
        
        /* 頂部資訊列 */
        .top-bar { 
            background: rgba(20,20,20,0.9); padding: 10px 15px; flex-shrink: 0; z-index: 20;
            display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid #333;
            padding-top: max(10px, env(safe-area-inset-top));
        }
        
        select { background: #222; color: #fff; border: 1px solid #555; padding: 6px; border-radius: 6px; font-size: 13px; max-width: 120px; }
        
        .hdr-status {
            font-size: 11px; font-weight: bold; padding: 4px 8px; border-radius: 4px;
            transition: 0.3s; text-transform: uppercase;
        }
        .hdr-on { background: #ffaa00; color: #000; box-shadow: 0 0 10px rgba(255, 170, 0, 0.4); }
        .hdr-off { background: #333; color: #888; }

        /* 視窗與分析儀 */
        .viewport { 
            flex-grow: 1; position: relative; background: #000; overflow: hidden;
            display: flex; justify-content: center; align-items: center; 
        }
        video { width: 100%; height: 100%; object-fit: contain; }

        /* 動態範圍分析儀 HUD */
        #analyzer-hud {
            position: absolute; bottom: 20px; left: 20px; 
            background: rgba(0,0,0,0.6); padding: 10px; border-radius: 8px;
            display: flex; flex-direction: column; gap: 5px; pointer-events: none;
            backdrop-filter: blur(4px); border: 1px solid rgba(255,255,255,0.1);
        }
        .hud-label { font-size: 10px; color: #aaa; text-transform: uppercase; }
        .hud-bar-bg { width: 120px; height: 6px; background: #333; border-radius: 3px; overflow: hidden; }
        .hud-bar-fill { height: 100%; background: linear-gradient(90deg, #00ff88, #ffaa00, #ff4444); width: 0%; transition: width 0.2s; }
        .hud-value { font-size: 12px; font-family: monospace; font-weight: bold; color: #fff; }

        /* 處理中遮罩 */
        #proc-mask {
            position: absolute; inset: 0; background: rgba(0,0,0,0.85); z-index: 50;
            display: none; justify-content: center; align-items: center; flex-direction: column; gap: 15px;
        }
        .spinner { width: 40px; height: 40px; border: 4px solid #333; border-top-color: #ffaa00; border-radius: 50%; animation: spin 1s infinite linear; }
        
        /* 底部控制區 */
        .controls { 
            background: #111; padding: 15px 20px; flex-shrink: 0; z-index: 20;
            border-top: 1px solid #333; display: flex; flex-direction: column; gap: 12px; align-items: center;
            padding-bottom: max(20px, env(safe-area-inset-bottom));
        }

        /* 參數滑桿組 */
        .slider-group { width: 100%; display: flex; flex-direction: column; gap: 8px; }
        .slider-row { display: flex; align-items: center; gap: 10px; font-size: 12px; font-weight: bold; }
        .label { width: 60px; color: #aaa; text-align: right; }
        
        input[type=range] { flex-grow: 1; height: 4px; border-radius: 2px; -webkit-appearance: none; background: #444; }
        input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; width: 16px; height: 16px; border-radius: 50%; background: #fff; box-shadow: 0 0 5px rgba(0,0,0,0.5); }
        
        .ac-hdr input { accent-color: #ffaa00; }
        .ac-zoom input { accent-color: #00ff88; }
        .ac-aperture input { accent-color: #00d2ff; }

        /* 快門 */
        .shutter {
            width: 70px; height: 70px; border-radius: 50%;
            border: 4px solid rgba(255,255,255,0.2);
            background: radial-gradient(circle, #fff 30%, #ffaa00 100%);
            cursor: pointer; transition: 0.1s; position: relative;
            box-shadow: 0 0 20px rgba(255, 170, 0, 0.2);
            margin-top: 5px;
        }
        .shutter:active { transform: scale(0.9); }
        
        @keyframes spin { 100% { transform: rotate(360deg); } }
        canvas { display: none; }
    </style>
</head>
<body>

    <!-- 銳化濾鏡 -->
    <svg style="width:0;height:0;position:absolute;">
        <defs><filter id="smart-sharpen"><feConvolveMatrix order="3" kernelMatrix="0 -1 0 -1 5 -1 0 -1 0"/></filter></defs>
    </svg>

    <div class="top-bar">
        <select id="cameraSelect"><option>Loading...</option></select>
        <div id="hdrStatusBadge" class="hdr-status hdr-off">Auto HDR</div>
        <!-- 開關 -->
        <div style="font-size:12px; display:flex; align-items:center; gap:5px;">
            <input type="checkbox" id="hdrToggle" checked> <span>啟用</span>
        </div>
    </div>

    <div class="viewport">
        <video id="videoPreview" autoplay playsinline muted></video>
        
        <!-- 場景分析儀 HUD -->
        <div id="analyzer-hud">
            <div class="hud-label">SCENE CONTRAST</div>
            <div class="hud-bar-bg"><div id="dr-bar" class="hud-bar-fill"></div></div>
            <div class="hud-value"><span id="dr-val">0</span>% <span id="dr-msg" style="color:#aaa; font-weight:normal">(Analyzing)</span></div>
        </div>

        <div id="proc-mask">
            <div class="spinner"></div>
            <div id="proc-msg" style="color:#ffaa00; font-weight:bold;">Processing...</div>
        </div>
    </div>

    <div class="controls">
        <div class="slider-group">
            <!-- HDR 強度 -->
            <div class="slider-row ac-hdr">
                <span class="label">HDR 強度</span>
                <input type="range" id="strengthSlider" min="0" max="100" value="70">
            </div>
            <!-- 光圈 (模擬 EV) -->
            <div class="slider-row ac-aperture">
                <span class="label">光圈 f/</span>
                <input type="range" id="apertureSlider" min="-3" max="3" step="0.5" value="0">
            </div>
            <!-- 變焦 -->
            <div class="slider-row ac-zoom">
                <span class="label">Zoom</span>
                <input type="range" id="zoomSlider" min="1" max="8" step="0.1" value="1" disabled>
            </div>
        </div>

        <div class="shutter" onclick="smartCapture()"></div>
    </div>

    <!-- 運算用 -->
    <canvas id="cLow"></canvas>
    <canvas id="cMid"></canvas>
    <canvas id="cHigh"></canvas>
    <canvas id="cFinal"></canvas>
    <canvas id="cAnalysis" width="64" height="64"></canvas>

<script>
    const video = document.getElementById('videoPreview');
    const hdrBadge = document.getElementById('hdrStatusBadge');
    const drBar = document.getElementById('dr-bar');
    const drVal = document.getElementById('dr-val');
    const drMsg = document.getElementById('dr-msg');
    const procMask = document.getElementById('proc-mask');
    const procMsg = document.getElementById('proc-msg');
    const hdrToggle = document.getElementById('hdrToggle');

    let currentStream, videoTrack, imageCapture;
    let hardwareExposure = false;
    let sceneDynamicRange = 0; // 0-100
    let analysisInterval;

    // 初始化
    async function init() {
        try {
            const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' } });
            setupCamera(stream);
            
            const devices = await navigator.mediaDevices.enumerateDevices();
            const cams = devices.filter(d => d.kind === 'videoinput');
            const sel = document.getElementById('cameraSelect');
            sel.innerHTML = '';
            cams.forEach((d, i) => {
                const opt = document.createElement('option');
                opt.value = d.deviceId;
                opt.text = d.label || `Lens ${i+1}`;
                sel.appendChild(opt);
            });
            if(cams.length > 0) switchCamera(cams[cams.length-1].deviceId);
            sel.onchange = e => switchCamera(e.target.value);

            // 啟動即時分析循環
            startAnalyzer();

        } catch(e) { alert("請允許相機權限"); }
    }

    async function switchCamera(id) {
        if(currentStream) currentStream.getTracks().forEach(t=>t.stop());
        try {
            const s = await navigator.mediaDevices.getUserMedia({ video: { deviceId: { exact: id }, width: { ideal: 4096 } } });
            setupCamera(s);
        } catch(e) {
            try { 
                const s2 = await navigator.mediaDevices.getUserMedia({ video: { deviceId: { exact: id } } });
                setupCamera(s2);
            } catch(e2) {}
        }
    }

    function setupCamera(stream) {
        currentStream = stream;
        video.srcObject = stream;
        videoTrack = stream.getVideoTracks()[0];
        if(window.ImageCapture) try{imageCapture = new ImageCapture(videoTrack)}catch(e){}

        const caps = videoTrack.getCapabilities ? videoTrack.getCapabilities() : {};
        
        // 設定變焦
        const zs = document.getElementById('zoomSlider');
        if(caps.zoom) {
            zs.disabled = false;
            zs.min = caps.zoom.min;
            zs.max = Math.min(caps.zoom.max, 8);
            zs.step = 0.1;
            zs.value = 1;
            zs.oninput = function() { videoTrack.applyConstraints({advanced:[{zoom:this.value}]}); }
        }

        // 設定曝光 (光圈模擬)
        hardwareExposure = !!caps.exposureCompensation;
        const as = document.getElementById('apertureSlider');
        if (hardwareExposure) {
            // 對應用戶的習慣：滑桿往右(數值大) = 光圈大(變亮) = EV+
            // 但物理上 f/數值 小 = 光圈大。為了直覺，我們顯示 f/stop 概念但滑桿邏輯是亮度
            as.disabled = false;
            as.oninput = function() { 
                // 直接調整 EV 作為光圈模擬
                setEV(parseFloat(this.value)); 
            }
        } else {
            as.disabled = true; // 不支援硬體曝光
        }
    }

    // ★★★ 核心 1：即時場景分析 (Scene Analyzer) ★★★
    function startAnalyzer() {
        if(analysisInterval) clearInterval(analysisInterval);
        const cvs = document.getElementById('cAnalysis');
        const ctx = cvs.getContext('2d');

        analysisInterval = setInterval(() => {
            if(video.readyState !== 4) return;
            
            // 1. 抓縮圖 (64x64)
            ctx.drawImage(video, 0, 0, 64, 64);
            const data = ctx.getImageData(0, 0, 64, 64).data;
            
            // 2. 計算亮度分佈 (Histogram)
            let minLuma = 255, maxLuma = 0;
            
            // 採樣 (每4個點採一次加速)
            for(let i=0; i<data.length; i+=16) {
                // Y = 0.299R + 0.587G + 0.114B
                const luma = data[i]*0.299 + data[i+1]*0.587 + data[i+2]*0.114;
                if(luma < minLuma) minLuma = luma;
                if(luma > maxLuma) maxLuma = luma;
            }

            // 3. 計算動態範圍分數 (0-100)
            // 差異越大，代表場景反差越大 (如逆光)
            sceneDynamicRange = Math.round(((maxLuma - minLuma) / 255) * 100);

            // 4. 更新 UI
            drBar.style.width = `${sceneDynamicRange}%`;
            drVal.innerText = sceneDynamicRange;
            
            // 5. 決策邏輯
            const isHDREnabled = hdrToggle.checked;
            // 閾值：如果反差 > 60%，判定為高反差場景
            if (isHDREnabled && sceneDynamicRange > 60) {
                drMsg.innerText = "(High Contrast)";
                hdrBadge.className = "hdr-status hdr-on";
                hdrBadge.innerText = "HDR: ON (3-Shot)";
                drBar.style.background = "linear-gradient(90deg, #ffaa00, #ff4444)";
            } else if (isHDREnabled) {
                drMsg.innerText = "(Normal)";
                hdrBadge.className = "hdr-status hdr-off";
                hdrBadge.innerText = "HDR: Auto-Off"; // 雖然開著，但場景不需要
                drBar.style.background = "#00ff88";
            } else {
                hdrBadge.className = "hdr-status hdr-off";
                hdrBadge.innerText = "HDR: Disabled";
            }

        }, 500); // 每 0.5 秒分析一次
    }

    // ★★★ 核心 2：智慧拍攝 (Smart Capture) ★★★
    async function smartCapture() {
        procMask.style.display = 'flex';
        
        // 讀取當前設定 (光圈偏移量)
        const baseEV = parseFloat(document.getElementById('apertureSlider').value);
        const strength = parseInt(document.getElementById('strengthSlider').value) / 100;
        const isHDREnabled = hdrToggle.checked;
        const needsHDR = sceneDynamicRange > 60; // 根據分析結果決定

        try {
            if (isHDREnabled && needsHDR) {
                // [方案 A] 高反差：觸發包圍曝光
                procMsg.innerText = "偵測到高反差... 啟動 HDR 合成";
                
                // 1. 基準 (EV + Base)
                await setEV(baseEV);
                await sleep(150);
                const mid = await grab();

                // 2. 暗部 (EV + Base + 2.0)
                await setEV(baseEV + 2.0);
                await sleep(150);
                const high = await grab();

                // 3. 亮部 (EV + Base - 2.0)
                await setEV(baseEV - 2.0);
                await sleep(150);
                const low = await grab();

                // 4. 合成
                await processHDR(low, mid, high, strength);

            } else {
                // [方案 B] 一般場景：單張拍攝 (如果有設定光圈EV，還是要應用)
                procMsg.innerText = "拍攝中...";
                await setEV(baseEV);
                await sleep(100);
                const single = await grab();
                
                // 應用一點銳化
                applySharpen(single);
                save(single, "Photo");
            }

        } catch(e) {
            console.error(e);
            alert("拍攝錯誤");
        } finally {
            // 恢復原本的光圈/EV設定
            setEV(baseEV);
            procMask.style.display = 'none';
        }
    }

    // HDR 合成演算法 (Darken/Lighten)
    async function processHDR(low, mid, high, strength) {
        const canvas = document.getElementById('cFinal');
        canvas.width = mid.width; canvas.height = mid.height;
        const ctx = canvas.getContext('2d');

        // 1. 底圖
        ctx.drawImage(mid, 0, 0);

        // 2. 疊加欠曝圖 (救天空) - Darken
        ctx.globalCompositeOperation = 'darken';
        ctx.globalAlpha = strength;
        ctx.drawImage(low, 0, 0);

        // 3. 疊加過曝圖 (救陰影) - Lighten
        ctx.globalCompositeOperation = 'lighten';
        ctx.globalAlpha = strength;
        ctx.drawImage(high, 0, 0);

        // 4. Tone Mapping (Soft Light 增強對比)
        ctx.globalCompositeOperation = 'soft-light';
        ctx.globalAlpha = 0.4; // 固定增強
        ctx.drawImage(mid, 0, 0);

        // 5. 輸出
        ctx.globalCompositeOperation = 'source-over';
        ctx.globalAlpha = 1.0;
        
        applySharpenCanvas(ctx, canvas.width, canvas.height);
        
        save(canvas, "SmartHDR");
    }

    // 輔助函式
    async function setEV(val) {
        if(hardwareExposure) {
            try { await videoTrack.applyConstraints({advanced:[{exposureCompensation: val}]}); } catch(e){}
        }
    }
    
    async function grab() {
        if(imageCapture) try{return await imageCapture.grabFrame()}catch(e){}
        const c = document.createElement('canvas'); c.width=video.videoWidth; c.height=video.videoHeight;
        c.getContext('2d').drawImage(video,0,0);
        return c;
    }

    function applySharpenCanvas(ctx, w, h) {
        const t = document.createElement('canvas'); t.width=w; t.height=h;
        t.getContext('2d').drawImage(ctx.canvas,0,0);
        ctx.filter = 'url(#smart-sharpen) contrast(1.05)';
        ctx.clearRect(0,0,w,h);
        ctx.drawImage(t,0,0);
        ctx.filter = 'none';
    }
    
    function applySharpen(sourceCanvas) {
        const ctx = sourceCanvas.getContext('2d');
        const w = sourceCanvas.width, h = sourceCanvas.height;
        const t = document.createElement('canvas'); t.width=w; t.height=h;
        t.getContext('2d').drawImage(sourceCanvas,0,0);
        ctx.filter = 'url(#smart-sharpen)';
        ctx.clearRect(0,0,w,h);
        ctx.drawImage(t,0,0);
        ctx.filter = 'none';
    }

    function save(canvas, prefix) {
        const link = document.createElement('a');
        link.download = `${prefix}_${Date.now()}.jpg`;
        link.href = canvas.toDataURL('image/jpeg', 0.95);
        link.click();
    }
    
    function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

    init();
</script>
</body>
</html>

