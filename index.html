<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>AI Hybrid Cam (Final Fix)</title>
    <style>
        body { margin: 0; background: #000; font-family: -apple-system, Roboto, sans-serif; color: white; height: 100dvh; display: flex; flex-direction: column; overflow: hidden; }
        
        /* 頂部 */
        .top-bar { 
            background: rgba(20,20,25,0.95); padding: 8px 12px; z-index: 20;
            display: flex; flex-direction: column; gap: 8px; border-bottom: 1px solid #333;
            padding-top: max(10px, env(safe-area-inset-top));
        }
        
        .row { display: flex; justify-content: space-between; align-items: center; width: 100%; gap: 8px; }
        
        select { background: #222; color: #fff; border: 1px solid #555; padding: 6px; border-radius: 6px; font-size: 13px; flex-grow: 1; max-width: 120px; }
        
        /* 功能開關 */
        .toggle-btn {
            background: #222; border: 1px solid #444; color: #aaa; padding: 4px 10px; border-radius: 12px; font-size: 11px; cursor: pointer; display: flex; align-items: center; gap: 5px;
        }
        .toggle-btn input { margin: 0; }
        .toggle-btn.active { border-color: #00d2ff; color: #00d2ff; font-weight: bold; }
        
        /* 視窗 */
        .viewport { 
            flex-grow: 1; position: relative; background: #111; overflow: hidden;
            display: flex; justify-content: center; align-items: center; 
        }
        video { width: 100%; height: 100%; object-fit: contain; }

        /* 狀態標籤 */
        #status-pill {
            position: absolute; top: 15px; left: 15px;
            background: rgba(0,0,0,0.6); padding: 4px 10px; border-radius: 15px;
            font-size: 11px; color: #00ff88; border: 1px solid rgba(0,255,136,0.3); pointer-events: none; z-index: 10;
        }
        .warn-mode { color: #ffd700 !important; border-color: #ffd700 !important; }

        /* 拍攝遮罩 */
        #mask {
            position: absolute; inset: 0; background: rgba(0,0,0,0.9); z-index: 50;
            display: none; justify-content: center; align-items: center; flex-direction: column; gap: 15px;
        }
        .spinner {
            width: 40px; height: 40px; border-radius: 50%;
            border: 3px solid #333; border-top: 3px solid #00d2ff;
            animation: spin 1s infinite linear;
        }
        
        /* 底部 */
        .controls { 
            background: #111; padding: 15px 20px; flex-shrink: 0; z-index: 20;
            border-top: 1px solid #333; display: flex; flex-direction: column; gap: 15px; align-items: center;
            padding-bottom: max(25px, env(safe-area-inset-bottom));
        }

        .slider-row { width: 100%; display: flex; align-items: center; gap: 10px; font-size: 12px; font-weight: bold; color: #aaa; }
        input[type=range] { flex-grow: 1; height: 4px; border-radius: 2px; -webkit-appearance: none; background: #444; }
        input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; width: 16px; height: 16px; border-radius: 50%; background: #fff; }
        
        .ac-zoom input { accent-color: #00ff88; }
        .ac-ev input { accent-color: #00d2ff; }

        .shutter {
            width: 72px; height: 72px; border-radius: 50%;
            border: 4px solid rgba(255,255,255,0.3);
            background: radial-gradient(circle, #fff 30%, #00d2ff 100%);
            cursor: pointer; transition: 0.1s; position: relative;
            box-shadow: 0 0 20px rgba(0, 210, 255, 0.3);
        }
        .shutter:active { transform: scale(0.95); }

        @keyframes spin { 100% { transform: rotate(360deg); } }
        canvas { display: none; }
    </style>
</head>
<body>

    <svg style="width:0;height:0;position:absolute;">
        <defs>
            <filter id="smart-sharpen"><feConvolveMatrix order="3" kernelMatrix="0 -1 0 -1 5 -1 0 -1 0"/></filter>
            <filter id="upscale-sharpen"><feConvolveMatrix order="3" kernelMatrix="0 -0.5 0 -0.5 3 -0.5 0 -0.5 0"/></filter>
        </defs>
    </svg>

    <div class="top-bar">
        <div class="row">
            <select id="cameraSelect"><option>Loading...</option></select>
            <select id="hdrCount" style="max-width: 60px;">
                <option value="3">3張</option>
                <option value="5">5張</option>
                <option value="7">7張</option>
            </select>
        </div>
        <div class="row">
            <label class="toggle-btn active" id="hdrBtn">
                <input type="checkbox" id="hdrToggle" checked onchange="toggleStyle(this, 'hdrBtn')"> HDR
            </label>
            <label class="toggle-btn" id="upscaleBtn">
                <input type="checkbox" id="upscaleToggle" onchange="toggleStyle(this, 'upscaleBtn')"> 2x AI Upscale
            </label>
            <label class="toggle-btn" id="rawBtn">
                <input type="checkbox" id="rawToggle" onchange="toggleStyle(this, 'rawBtn')"> PNG
            </label>
        </div>
    </div>

    <div class="viewport">
        <video id="videoPreview" autoplay playsinline muted></video>
        <div id="status-pill">Init...</div>
        
        <div id="mask">
            <div class="spinner"></div>
            <div id="mask-text" style="color:#00d2ff; font-family:monospace;">Processing...</div>
        </div>
    </div>

    <div class="controls">
        <div class="slider-row ac-ev">
            <span>EV</span>
            <input type="range" id="evRange" min="-3" max="3" step="0.5" value="0">
            <span id="evText" style="width:25px; text-align:right">0</span>
        </div>
        <div class="slider-row ac-zoom">
            <span>Zoom</span>
            <input type="range" id="zoomSlider" min="1" max="8" step="0.1" value="1" disabled>
            <span id="zoomText" style="width:25px; text-align:right">1.0</span>
        </div>
        <div class="shutter" onclick="capture()"></div>
    </div>

    <canvas id="cFinal"></canvas>
    <canvas id="cUpscale"></canvas>

<script>
    const video = document.getElementById('videoPreview');
    const statusPill = document.getElementById('status-pill');
    const mask = document.getElementById('mask');
    const maskText = document.getElementById('mask-text');
    
    let currentStream, videoTrack, imageCapture;
    let hardwareExposure = false;
    let isSafeMode = false;

    async function init() {
        try {
            const stream = await navigator.mediaDevices.getUserMedia({ video: true });
            stream.getTracks().forEach(t => t.stop());
            
            const devices = await navigator.mediaDevices.enumerateDevices();
            const cams = devices.filter(d => d.kind === 'videoinput');
            
            const sel = document.getElementById('cameraSelect');
            sel.innerHTML = '';
            cams.forEach((d, i) => {
                const opt = document.createElement('option');
                opt.value = d.deviceId;
                opt.text = d.label || `Camera ${i}`;
                sel.appendChild(opt);
            });

            if(cams.length > 0) switchCamera(cams[cams.length-1].deviceId);
            sel.onchange = e => switchCamera(e.target.value);

        } catch(e) { alert("請允許相機權限"); }
    }

    // ★★★ 核心修正：主動式黑屏偵測與降級 ★★★
    async function switchCamera(id) {
        if(currentStream) currentStream.getTracks().forEach(t => t.stop());
        statusPill.innerText = "啟動中...";
        isSafeMode = false;

        try {
            // 嘗試 1: 4K 高畫質預覽
            await launch({ video: { deviceId: { exact: id }, width: { ideal: 4096 }, height: { ideal: 4096 }, aspectRatio: 1.333 } }, "4K Preview");
        } catch(e1) {
            console.log("4K Preview failed (or black screen detected), switching to Safe Mode...");
            try {
                // 嘗試 2: VGA 安全模式 (保證有畫面)
                await launch({ video: { deviceId: { exact: id }, width: { ideal: 640 }, height: { ideal: 480 } } }, "Safe Preview");
                isSafeMode = true; 
            } catch(e2) {
                statusPill.innerText = "Fatal Error";
                alert("此鏡頭無法啟動");
            }
        }
    }

    function launch(constraints, label) {
        return new Promise(async (resolve, reject) => {
            try {
                const stream = await navigator.mediaDevices.getUserMedia(constraints);
                currentStream = stream;
                video.srcObject = stream;
                
                // 關鍵：等待畫面真正出現
                const playPromise = video.play();
                if (playPromise !== undefined) {
                    playPromise.catch(error => {
                        console.error("Auto-play was prevented");
                    });
                }

                // 設定超時機制：如果 1.5秒內沒有 loadedmetadata 或寬度為 0，視為失敗
                const timeoutId = setTimeout(() => {
                    reject(new Error("Timeout waiting for video"));
                }, 1500);

                video.onloadedmetadata = () => {
                    clearTimeout(timeoutId);
                    
                    // 黑屏偵測：如果寬度是 0，代表失敗
                    if (video.videoWidth === 0 || video.videoHeight === 0) {
                        reject(new Error("Black screen detected (0x0)"));
                        return;
                    }

                    videoTrack = stream.getVideoTracks()[0];
                    
                    // 初始化 ImageCapture (拍照清晰的關鍵)
                    if(window.ImageCapture) {
                        try { imageCapture = new ImageCapture(videoTrack); } catch(e){}
                    }

                    // 能力偵測
                    const caps = videoTrack.getCapabilities ? videoTrack.getCapabilities() : {};
                    const zs = document.getElementById('zoomSlider');
                    if(caps.zoom) {
                        zs.disabled = false;
                        zs.min = caps.zoom.min;
                        zs.max = Math.min(caps.zoom.max, 8);
                        zs.value = 1;
                        zs.oninput = function() { 
                            document.getElementById('zoomText').innerText = parseFloat(this.value).toFixed(1);
                            videoTrack.applyConstraints({advanced:[{zoom:this.value}]}); 
                        }
                    } else { zs.disabled = true; }

                    hardwareExposure = !!caps.exposureCompensation;

                    // UI 更新
                    if(isSafeMode || label.includes("Safe")) {
                        statusPill.innerText = `⚠️ Safe Preview (Capture is HQ)`;
                        statusPill.className = "warn-mode";
                    } else {
                        statusPill.innerText = `✅ ${label}`;
                        statusPill.className = "";
                    }
                    
                    resolve(); // 成功
                };
                
                video.onerror = () => reject(new Error("Video Error"));

            } catch(e) {
                reject(e);
            }
        });
    }

    async function capture() {
        mask.style.display = 'flex';
        const isHdr = document.getElementById('hdrToggle').checked;
        
        try {
            // 無論預覽畫質如何，拍照一律嘗試調用硬體最高畫質
            if(!isHdr) {
                maskText.innerText = "Capturing HQ...";
                const bmp = await grabHighQuality();
                await finalize(bmp, "Photo");
            } else {
                const count = parseInt(document.getElementById('hdrCount').value);
                const frames = [];
                const startEv = -((count-1)/2); // EV Step 1.0
                
                // 如果是 SafeMode (預覽很糊)，連拍時必須強制用 takePhoto (慢但清晰)
                // 如果是正常模式，用 grabFrame (快)
                const useSlowPath = isSafeMode; 

                for(let i=0; i<count; i++) {
                    const ev = startEv + i;
                    maskText.innerText = `HDR ${i+1}/${count} (EV ${ev})`;
                    
                    await setEV(ev);
                    await sleep(useSlowPath ? 400 : 150); // 慢速模式多等一下
                    
                    // 在安全模式下，強制使用 takePhoto 來確保 HDR 素材也是高畫質
                    const bmp = await grabHighQuality(useSlowPath); 
                    frames.push({ ev: ev, img: bmp });
                }
                
                await setEV(0);
                maskText.innerText = "Merging...";
                await processHDR(frames);
            }
        } catch(e) {
            console.error(e);
            alert("拍攝失敗: " + e.message);
            mask.style.display = 'none';
        }
    }

    // ★ 關鍵：強制獲取高品質影像 ★
    async function grabHighQuality(forceTakePhoto = false) {
        // 1. 如果有 ImageCapture 且 (強制慢速模式 或 預設優先)，嘗試 takePhoto
        // 這能繞過 VGA 預覽，直接命令硬體拍出 12MP 照片
        if(imageCapture && (forceTakePhoto || true)) { 
            try {
                const blob = await imageCapture.takePhoto();
                return await createImageBitmap(blob);
            } catch(e) { 
                console.log("takePhoto failed, trying grabFrame"); 
            }
        }
        
        // 2. 備援：如果 takePhoto 失敗，只好抓截圖
        // 注意：如果是 SafeMode 且走到這裡，照片會是 VGA (沒辦法了)
        const c = document.createElement('canvas');
        c.width = video.videoWidth; c.height = video.videoHeight;
        c.getContext('2d').drawImage(video, 0, 0);
        return c;
    }

    async function processHDR(frames) {
        const baseIdx = Math.floor(frames.length / 2);
        const base = frames[baseIdx];
        
        const canvas = document.getElementById('cFinal');
        canvas.width = base.img.width; canvas.height = base.img.height;
        const ctx = canvas.getContext('2d');
        
        ctx.drawImage(base.img, 0, 0);

        ctx.globalAlpha = 0.5;
        frames.forEach(f => {
            if(f.ev < 0) {
                ctx.globalCompositeOperation = 'darken';
                ctx.drawImage(f.img, 0, 0);
            } else if(f.ev > 0) {
                ctx.globalCompositeOperation = 'lighten';
                ctx.drawImage(f.img, 0, 0);
            }
        });

        ctx.globalCompositeOperation = 'source-over';
        ctx.globalAlpha = 1.0;
        applyFilter(ctx, 'url(#smart-sharpen) contrast(1.1)');
        
        await finalize(canvas, "HDR");
    }

    async function finalize(source, prefix) {
        const isUpscale = document.getElementById('upscaleToggle').checked;
        const isPng = document.getElementById('rawToggle').checked;
        
        let canvas = document.getElementById('cFinal');
        if(source instanceof ImageBitmap || source instanceof HTMLVideoElement) {
            canvas.width = source.width; canvas.height = source.height;
            canvas.getContext('2d').drawImage(source, 0, 0);
        } else { canvas = source; }

        if(isUpscale) {
            maskText.innerText = "Upscaling...";
            if(canvas.width * canvas.height > 20000000) {
                console.log("Skip upscale");
            } else {
                const upCvs = document.getElementById('cUpscale');
                upCvs.width = canvas.width * 2; upCvs.height = canvas.height * 2;
                const uCtx = upCvs.getContext('2d');
                uCtx.imageSmoothingEnabled = true;
                uCtx.imageSmoothingQuality = 'high';
                uCtx.drawImage(canvas, 0, 0, upCvs.width, upCvs.height);
                applyFilter(uCtx, 'url(#upscale-sharpen)');
                canvas = upCvs;
            }
        }

        const link = document.createElement('a');
        link.download = `${prefix}_${Date.now()}.${isPng ? 'png' : 'jpg'}`;
        link.href = canvas.toDataURL(isPng ? 'image/png' : 'image/jpeg', 0.95);
        link.click();
        
        mask.style.display = 'none';
    }

    async function setEV(val) { if(hardwareExposure) try{await videoTrack.applyConstraints({advanced:[{exposureCompensation:val}]})}catch(e){} }
    
    function applyFilter(ctx, filter) {
        const t = document.createElement('canvas'); t.width=ctx.canvas.width; t.height=ctx.canvas.height;
        t.getContext('2d').drawImage(ctx.canvas,0,0);
        ctx.filter = filter;
        ctx.clearRect(0,0,t.width,t.height);
        ctx.drawImage(t,0,0);
        ctx.filter = 'none';
    }

    function toggleStyle(el, labelId) { document.getElementById(labelId).classList.toggle('active', el.checked); }
    
    document.getElementById('evRange').oninput = function() { 
        document.getElementById('evText').innerText = this.value;
        setEV(parseFloat(this.value));
    };

    function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

    init();
</script>
</body>
</html>



