<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>AI True HDR (Tone Mapping)</title>
    <style>
        /* 介面佈局：確保在任何手機上都不跑版 */
        body { margin: 0; background: #000; font-family: -apple-system, sans-serif; color: white; height: 100dvh; display: flex; flex-direction: column; overflow: hidden; }
        
        .top-bar { 
            background: #111; padding: 10px 15px; flex-shrink: 0; z-index: 20;
            display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid #333;
            padding-top: max(10px, env(safe-area-inset-top));
        }
        
        select { background: #222; color: #fff; border: 1px solid #555; padding: 6px 10px; border-radius: 6px; font-size: 13px; max-width: 45%; }
        
        .status { font-size: 12px; color: #aaa; font-family: monospace; }
        .status.active { color: #00ff88; font-weight: bold; }

        .viewport { 
            flex-grow: 1; position: relative; background: #000; overflow: hidden;
            display: flex; justify-content: center; align-items: center; 
        }
        video { width: 100%; height: 100%; object-fit: contain; }

        /* HUD: 顯示曝光分析數據 */
        #hud {
            position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
            background: rgba(0,0,0,0.7); padding: 8px 15px; border-radius: 20px;
            display: none; align-items: center; gap: 10px; border: 1px solid #555; pointer-events: none;
        }
        .hud-dot { width: 8px; height: 8px; border-radius: 50%; background: #555; }
        .hud-dot.ok { background: #00ff88; box-shadow: 0 0 5px #00ff88; }
        .hud-text { font-size: 12px; color: #fff; }

        /* 底部控制區 */
        .controls { 
            background: #111; padding: 15px 20px; flex-shrink: 0; z-index: 20;
            border-top: 1px solid #333; display: flex; flex-direction: column; gap: 15px; align-items: center;
            padding-bottom: max(20px, env(safe-area-inset-bottom));
        }

        /* 參數滑桿 */
        .slider-group { width: 100%; display: flex; flex-direction: column; gap: 8px; }
        .slider-row { display: flex; align-items: center; gap: 10px; font-size: 12px; font-weight: bold; }
        .label { width: 50px; color: #aaa; }
        input[type=range] { flex-grow: 1; height: 4px; border-radius: 2px; -webkit-appearance: none; background: #444; }
        input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; width: 16px; height: 16px; border-radius: 50%; background: #fff; box-shadow: 0 0 5px rgba(0,0,0,0.5); }
        
        /* 顏色區分 */
        .accent-hdr { color: #ffaa00; }
        .accent-hdr input { accent-color: #ffaa00; }
        .accent-ev { color: #00d2ff; }
        .accent-ev input { accent-color: #00d2ff; }

        /* 快門 */
        .shutter {
            width: 70px; height: 70px; border-radius: 50%;
            border: 4px solid rgba(255,255,255,0.2);
            background: radial-gradient(circle, #fff 30%, #ffaa00 100%);
            cursor: pointer; transition: 0.1s; position: relative;
            box-shadow: 0 0 20px rgba(255, 170, 0, 0.3);
        }
        .shutter:active { transform: scale(0.9); }
        
        /* 運算中的遮罩 */
        #processing-mask {
            position: absolute; inset: 0; background: rgba(0,0,0,0.8); z-index: 50;
            display: none; justify-content: center; align-items: center; flex-direction: column; gap: 15px;
        }
        .spinner { width: 40px; height: 40px; border: 4px solid #333; border-top-color: #ffaa00; border-radius: 50%; animation: spin 1s infinite linear; }
        .proc-text { color: #ffaa00; font-weight: bold; font-size: 14px; }

        @keyframes spin { 100% { transform: rotate(360deg); } }
        canvas { display: none; }
    </style>
</head>
<body>

    <div class="top-bar">
        <select id="cameraSelect"><option>Loading...</option></select>
        <div id="status" class="status">HDR Ready</div>
    </div>

    <div class="viewport">
        <video id="videoPreview" autoplay playsinline muted></video>
        
        <!-- 即時曝光分析 HUD -->
        <div id="hud">
            <div id="hud-dot" class="hud-dot"></div>
            <div id="hud-text" class="hud-text">Analyzing Exposure...</div>
        </div>

        <!-- 處理遮罩 -->
        <div id="processing-mask">
            <div class="spinner"></div>
            <div id="proc-msg" class="proc-text">正在分析場景光線...</div>
        </div>
    </div>

    <div class="controls">
        <div class="slider-group">
            <!-- HDR 強度滑桿 -->
            <div class="slider-row accent-hdr">
                <span class="label">強度</span>
                <input type="range" id="strengthSlider" min="0" max="100" value="70">
                <span style="width:30px; text-align:right">70%</span>
            </div>
            <!-- EV 範圍滑桿 -->
            <div class="slider-row accent-ev">
                <span class="label">範圍</span>
                <input type="range" id="evRangeSlider" min="1.0" max="3.0" step="0.5" value="2.0">
                <span id="evDisplay" style="width:30px; text-align:right">±2</span>
            </div>
        </div>

        <div class="shutter" onclick="startHDRCapture()"></div>
    </div>

    <!-- 畫布區 -->
    <canvas id="cLow"></canvas>
    <canvas id="cMid"></canvas>
    <canvas id="cHigh"></canvas>
    <canvas id="cFinal"></canvas>
    <canvas id="cAnalysis" width="32" height="32"></canvas>

<script>
    const video = document.getElementById('videoPreview');
    const hud = document.getElementById('hud');
    const hudDot = document.getElementById('hud-dot');
    const hudText = document.getElementById('hud-text');
    const procMask = document.getElementById('processing-mask');
    const procMsg = document.getElementById('proc-msg');
    
    let currentStream, videoTrack, imageCapture;
    let hardwareExposure = false;

    // 初始化
    async function init() {
        try {
            const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' } });
            setupCamera(stream);
            
            // 列出鏡頭
            const devices = await navigator.mediaDevices.enumerateDevices();
            const cams = devices.filter(d => d.kind === 'videoinput');
            const sel = document.getElementById('cameraSelect');
            sel.innerHTML = '';
            cams.forEach((d, i) => {
                const opt = document.createElement('option');
                opt.value = d.deviceId;
                opt.text = d.label || `鏡頭 ${i+1}`;
                sel.appendChild(opt);
            });
            sel.onchange = e => switchCamera(e.target.value);
            
            // 預設切換到後鏡頭
            if(cams.length > 0) switchCamera(cams[cams.length-1].deviceId);

        } catch(e) { alert("相機權限錯誤"); }
    }

    async function switchCamera(id) {
        if(currentStream) currentStream.getTracks().forEach(t=>t.stop());
        try {
            // 嘗試 4K
            const s = await navigator.mediaDevices.getUserMedia({ video: { deviceId: { exact: id }, width: { ideal: 4096 } } });
            setupCamera(s);
        } catch(e) {
            try { 
                const s2 = await navigator.mediaDevices.getUserMedia({ video: { deviceId: { exact: id } } });
                setupCamera(s2);
            } catch(e2) {}
        }
    }

    function setupCamera(stream) {
        currentStream = stream;
        video.srcObject = stream;
        videoTrack = stream.getVideoTracks()[0];
        if(window.ImageCapture) try{imageCapture = new ImageCapture(videoTrack)}catch(e){}

        // 檢查硬體支援
        const caps = videoTrack.getCapabilities ? videoTrack.getCapabilities() : {};
        const statusDiv = document.getElementById('status');
        
        if (caps.exposureCompensation) {
            hardwareExposure = true;
            statusDiv.innerText = "Pro HDR (Hard-EV)";
            statusDiv.classList.add('active');
            // 限制 EV 滑桿
            const maxEv = Math.min(Math.abs(caps.exposureCompensation.min), Math.abs(caps.exposureCompensation.max));
            document.getElementById('evRangeSlider').max = maxEv;
        } else {
            hardwareExposure = false;
            statusDiv.innerText = "Simulated HDR";
            statusDiv.classList.remove('active');
        }
    }

    // 更新滑桿顯示
    document.getElementById('evRangeSlider').oninput = function() {
        document.getElementById('evDisplay').innerText = `±${this.value}`;
    }

    // ★★★ 核心：HDR 拍攝流程 ★★★
    async function startHDRCapture() {
        procMask.style.display = 'flex';
        hud.style.display = 'flex';
        
        const evRange = parseFloat(document.getElementById('evRangeSlider').value);
        const strength = parseInt(document.getElementById('strengthSlider').value) / 100;

        let frameLow, frameMid, frameHigh;

        try {
            // 1. 拍攝基準圖 (EV 0)
            procMsg.innerText = "1/3 拍攝基準 (EV 0)...";
            await setEV(0);
            await waitStableExposure(0); // 等待亮度穩定
            frameMid = await grab();

            // 2. 拍攝暗圖 (EV -Range) -> 抓亮部
            procMsg.innerText = `2/3 拍攝高光 (EV -${evRange})...`;
            await setEV(-evRange);
            await waitStableExposure(-1); // 等待變暗
            frameLow = await grab();

            // 3. 拍攝亮圖 (EV +Range) -> 抓陰影
            procMsg.innerText = `3/3 拍攝暗部 (EV +${evRange})...`;
            await setEV(evRange);
            await waitStableExposure(1); // 等待變亮
            frameHigh = await grab();

            // 4. 合成運算
            procMsg.innerText = "正在進行 Tone Mapping...";
            await processHDR(frameLow, frameMid, frameHigh, strength);

        } catch(e) {
            console.error(e);
            alert("拍攝失敗: " + e.message);
        } finally {
            setEV(0); // 復原
            procMask.style.display = 'none';
            hud.style.display = 'none';
        }
    }

    // 等待曝光穩定的智慧鎖
    async function waitStableExposure(targetTrend) {
        if (!hardwareExposure) return; // 沒硬體就不用等
        
        hudText.innerText = "等待曝光調整...";
        hudDot.className = "hud-dot";

        const baseLuma = await getAverageLuma();
        let retries = 0;
        const maxRetries = 15; // 最多等 1.5 秒

        return new Promise(async resolve => {
            const check = async () => {
                const currentLuma = await getAverageLuma();
                let isStable = false;

                if (targetTrend === 0) {
                    // EV 0: 不需要比較，只要稍微等一下
                    if(retries > 2) isStable = true;
                } else if (targetTrend < 0) {
                    // 變暗: 當前亮度 < 基準亮度 * 0.8
                    if (currentLuma < baseLuma * 0.85) isStable = true;
                } else {
                    // 變亮: 當前亮度 > 基準亮度 * 1.2
                    if (currentLuma > baseLuma * 1.15) isStable = true;
                }

                if (isStable || retries >= maxRetries) {
                    hudDot.className = "hud-dot ok";
                    hudText.innerText = "曝光鎖定!";
                    resolve();
                } else {
                    retries++;
                    setTimeout(check, 100); // 每 100ms 檢查一次
                }
            };
            check();
        });
    }

    async function getAverageLuma() {
        if (window.ImageCapture && imageCapture) {
            // 抓縮圖分析
            try {
                const bmp = await imageCapture.grabFrame();
                const cvs = document.getElementById('cAnalysis');
                const ctx = cvs.getContext('2d');
                ctx.drawImage(bmp, 0, 0, 32, 32);
                const data = ctx.getImageData(0,0,32,32).data;
                let sum = 0;
                for(let i=0; i<data.length; i+=4) {
                    // Y = 0.299R + 0.587G + 0.114B
                    sum += data[i]*0.299 + data[i+1]*0.587 + data[i+2]*0.114;
                }
                return sum / (32*32);
            } catch(e) { return 128; }
        }
        return 128; // Fallback
    }

    async function setEV(val) {
        if(hardwareExposure) {
            try { await videoTrack.applyConstraints({advanced:[{exposureCompensation: val}]}); } catch(e){}
        }
    }

    async function grab() {
        if(imageCapture) try{return await imageCapture.grabFrame()}catch(e){}
        const c = document.createElement('canvas'); c.width=video.videoWidth; c.height=video.videoHeight;
        c.getContext('2d').drawImage(video,0,0);
        return c;
    }

    // ★★★ 真 HDR 合成演算法 ★★★
    async function processHDR(low, mid, high, strength) {
        const w = mid.width;
        const h = mid.height;
        const canvas = document.getElementById('cFinal');
        canvas.width = w; canvas.height = h;
        const ctx = canvas.getContext('2d');

        // 1. 基底
        ctx.drawImage(mid, 0, 0);

        // 2. 修復高光 (Highlight Recovery)
        // 使用 'Darken' 模式：只有當「欠曝圖」比「基準圖」暗的時候才取代。
        // 這能完美把過曝死白的天空換成有細節的藍天，但完全不影響原本就暗的地面。
        ctx.globalCompositeOperation = 'darken';
        ctx.globalAlpha = strength; // 由滑桿控制強度
        ctx.drawImage(low, 0, 0);

        // 3. 修復陰影 (Shadow Recovery)
        // 使用 'Lighten' 模式：只有當「過曝圖」比「目前結果」亮的時候才取代。
        // 這能把死黑的陰影提亮，但完全不影響原本就亮的天空。
        ctx.globalCompositeOperation = 'lighten';
        ctx.globalAlpha = strength; 
        ctx.drawImage(high, 0, 0);

        // 4. Local Tone Mapping (模擬人眼對比)
        // 使用 'Overlay' 疊加一層模糊的反轉遮罩，這是經典的 Unsharp Mask 增強法
        ctx.globalCompositeOperation = 'overlay';
        ctx.globalAlpha = 0.3; // 固定 30% 增加通透感
        
        // 製作一個對比增強層
        const tempCvs = document.createElement('canvas');
        tempCvs.width = w; tempCvs.height = h;
        const tCtx = tempCvs.getContext('2d');
        tCtx.drawImage(mid, 0, 0);
        tCtx.filter = 'contrast(1.5) saturate(0)'; // 高對比黑白
        tCtx.drawImage(tempCvs, 0, 0); 
        
        ctx.drawImage(tempCvs, 0, 0);

        // 5. 存檔
        ctx.globalCompositeOperation = 'source-over';
        ctx.globalAlpha = 1.0;
        
        const link = document.createElement('a');
        link.download = `True_HDR_${Date.now()}.jpg`;
        link.href = canvas.toDataURL('image/jpeg', 0.95);
        link.click();
    }

    init();
</script>
</body>
</html>

