<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>AI 100MP Pro (Cloud & Storage)</title>
    <!-- å¼•å…¥ OpenCV.js -->
    <script async src="https://docs.opencv.org/4.5.0/opencv.js" onload="onOpenCvReady();" type="text/javascript"></script>
    <!-- å¼•å…¥ Firebase SDK (ç”¨æ–¼é›²ç«¯åŒæ­¥åŠŸèƒ½) -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, collection, addDoc, serverTimestamp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        window.fbUtils = { initializeApp, getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged, getFirestore, collection, addDoc, serverTimestamp };
    </script>
    <style>
        :root { --accent: #00d2ff; --warn: #ffd700; --active: #00ff88; --bg: #000; --panel: #111; }
        body { margin: 0; background: var(--bg); font-family: -apple-system, Roboto, sans-serif; color: white; height: 100dvh; display: flex; flex-direction: column; overflow: hidden; user-select: none; }
        
        /* --- é ‚éƒ¨å·¥å…·åˆ— --- */
        .top-bar { 
            background: rgba(20,20,25,0.95); padding: 8px 12px; z-index: 20;
            display: flex; flex-direction: column; gap: 10px; border-bottom: 1px solid #333;
            padding-top: max(10px, env(safe-area-inset-top));
        }
        
        .row { display: flex; justify-content: space-between; align-items: center; width: 100%; gap: 8px; }
        
        .fs-btn { 
            background: #222; border: 1px solid #444; color: #fff; 
            width: 32px; height: 32px; border-radius: 8px; display: flex; justify-content: center; align-items: center; cursor: pointer; font-size: 16px;
        }
        .fs-btn:active { background: #444; }

        select { background: #222; color: #fff; border: 1px solid #555; padding: 6px; border-radius: 6px; font-size: 12px; flex-grow: 1; max-width: 140px; }
        
        .engine-status { font-size: 10px; color: #666; display: flex; align-items: center; gap: 4px; border: 1px solid #333; padding: 2px 6px; border-radius: 4px; white-space: nowrap; }
        .engine-status.ready { color: var(--accent); border-color: var(--accent); }
        .dot { width: 6px; height: 6px; border-radius: 50%; background: currentColor; }

        .scroll-row { overflow-x: auto; padding-bottom: 4px; display: flex; gap: 8px; scrollbar-width: none; }
        .scroll-row::-webkit-scrollbar { display: none; }

        /* ä¸€èˆ¬æŒ‰éˆ• */
        .toggle-btn {
            background: #222; border: 1px solid #444; color: #aaa; padding: 5px 10px; border-radius: 12px; font-size: 11px; cursor: pointer; display: flex; align-items: center; gap: 4px; white-space: nowrap; flex-shrink: 0; transition: all 0.2s;
        }
        .toggle-btn input { margin: 0; display: none; }
        .toggle-btn.active { border-color: var(--accent); color: var(--accent); background: rgba(0, 210, 255, 0.1); font-weight: bold; }
        
        /* å„²å­˜é¸å–®æŒ‰éˆ• */
        .storage-btn-main { border-color: #ffaa00; color: #ffaa00; font-weight: bold; }
        .storage-btn-main.active { background: rgba(255, 170, 0, 0.2); }

        /* è¤‡åˆæŒ‰éˆ•ç¾¤çµ„ (HDR) */
        .btn-group {
            display: flex; align-items: center; background: #222; border: 1px solid #444; border-radius: 12px; overflow: hidden;
        }
        .btn-group .toggle-btn {
            border: none; border-radius: 0; padding-right: 5px; background: transparent; height: 100%;
        }
        .btn-group select {
            border: none; background: #1a1a1a; color: #aaa; font-size: 10px; height: 26px; padding: 0 2px; width: auto; max-width: 45px; border-left: 1px solid #444; border-radius: 0;
        }
        .btn-group.active { border-color: var(--accent); }
        .btn-group.active .toggle-btn { color: var(--accent); font-weight: bold; background: rgba(0, 210, 255, 0.1); }
        
        /* Ultra æŒ‰éˆ•æ¨£å¼ */
        .toggle-btn.ultra-btn.active { border-color: #ff0055; color: #ff0055; background: rgba(255, 0, 85, 0.15); box-shadow: 0 0 8px rgba(255, 0, 85, 0.4); }
        .toggle-btn.ultra-btn.disabled { opacity: 0.3; pointer-events: none; border-color: #333; filter: grayscale(100%); }

        /* è¦–çª—å€åŸŸ */
        .viewport { flex-grow: 1; position: relative; background: #050505; overflow: hidden; display: flex; justify-content: center; align-items: center; touch-action: none; }
        video { width: 100%; height: 100%; object-fit: contain; }

        #status-pill { position: absolute; top: 15px; left: 15px; background: rgba(0,0,0,0.6); padding: 4px 10px; border-radius: 15px; font-size: 11px; color: var(--active); border: 1px solid rgba(0,255,136,0.3); pointer-events: none; z-index: 10; }
        .warn-mode { color: var(--warn) !important; border-color: var(--warn) !important; }

        /* å„²å­˜è¨­å®šé¢æ¿ */
        #storage-panel {
            position: absolute; bottom: 100px; left: 15px; right: 15px;
            background: rgba(20,20,25,0.98); border: 1px solid #444; border-radius: 16px;
            padding: 15px; display: none; flex-direction: column; gap: 12px; z-index: 100;
            box-shadow: 0 10px 30px rgba(0,0,0,0.8);
        }
        .panel-title { font-size: 14px; font-weight: bold; color: #ffaa00; margin-bottom: 5px; display: flex; justify-content: space-between; }
        .storage-option {
            background: #222; border: 1px solid #333; padding: 10px; border-radius: 10px;
            display: flex; align-items: center; gap: 10px; cursor: pointer; transition: 0.2s;
        }
        .storage-option.selected { border-color: #ffaa00; background: rgba(255, 170, 0, 0.1); }
        .storage-option .icon { font-size: 20px; width: 30px; text-align: center; }
        .storage-option .details { flex-grow: 1; }
        .storage-option .details h4 { margin: 0; font-size: 12px; }
        .storage-option .details p { margin: 0; font-size: 10px; color: #888; }

        /* HUD */
        #hud { position: absolute; inset: 0; background: rgba(0,0,0,0.9); z-index: 50; display: none; justify-content: center; align-items: center; flex-direction: column; gap: 15px; }
        .spinner { width: 50px; height: 50px; border-radius: 50%; border: 4px solid #333; border-top: 4px solid var(--active); border-right: 4px solid var(--accent); animation: spin 0.8s infinite linear; }
        .hud-text { font-family: monospace; color: #fff; font-size: 16px; text-align: center; font-weight: bold; }
        .hud-sub { color: #888; font-size: 12px; margin-top: 5px; max-width: 80%; text-align: center; line-height: 1.4; }

        /* Controls */
        .controls { background: var(--panel); padding: 10px 15px; flex-shrink: 0; z-index: 20; border-top: 1px solid #333; display: grid; grid-template-columns: 1fr 70px; gap: 10px; padding-bottom: max(20px, env(safe-area-inset-bottom)); }
        .sliders-col { display: flex; flex-direction: column; gap: 14px; justify-content: center; }
        .slider-row { width: 100%; display: flex; align-items: center; gap: 8px; font-size: 11px; font-weight: bold; color: #888; }
        .label { width: 40px; text-align: right; }
        .value-disp { width: 30px; text-align: right; font-family: monospace; color: #fff; }
        input[type=range] { flex-grow: 1; height: 4px; border-radius: 2px; -webkit-appearance: none; background: #333; }
        input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; width: 16px; height: 16px; border-radius: 50%; background: #ddd; box-shadow: 0 2px 5px rgba(0,0,0,0.5); }
        .shutter-col { display: flex; align-items: center; justify-content: center; }
        .shutter { width: 70px; height: 70px; border-radius: 50%; border: 4px solid rgba(255,255,255,0.2); background: radial-gradient(circle, #fff 30%, var(--accent) 100%); cursor: pointer; transition: 0.1s; position: relative; box-shadow: 0 0 20px rgba(0, 210, 255, 0.2); }
        .shutter:active { transform: scale(0.92); }

        @keyframes spin { 100% { transform: rotate(360deg); } }
        canvas { display: none; }
    </style>
</head>
<body>

    <div class="top-bar">
        <div class="row">
            <button class="fs-btn" onclick="toggleFullScreen()" title="å…¨è¢å¹•åˆ‡æ›">â›¶</button>
            <select id="cameraSelect"><option>Init...</option></select>
            <div id="cvStatus" class="engine-status"><div class="dot"></div> Loading CV...</div>
            <div class="light-group">
                <button class="light-btn active" id="light-off" onclick="setLightMode('off')">ğŸš«</button>
                <button class="light-btn" id="light-flash" onclick="setLightMode('flash')">âš¡</button>
                <button class="light-btn" id="light-torch" onclick="setLightMode('torch')">ğŸ”¦</button>
            </div>
        </div>
        
        <div class="row scroll-row">
            <!-- Storage Settings Button -->
            <label class="toggle-btn storage-btn-main" id="storageMainBtn" onclick="toggleStoragePanel()">
                ğŸ’¾ å„²å­˜è¨­å®š: <span id="currentStorageMode">ä¸‹è¼‰</span>
            </label>

            <div style="width:1px;height:20px;background:#333;margin:0 4px;"></div>

            <!-- Mode Buttons -->
            <label class="toggle-btn ultra-btn" id="ultraBtn" onclick="setResMode('ultra')">
                <input type="checkbox" id="ultraToggle"> 100MP
            </label>
            <label class="toggle-btn upscale-btn" id="upscaleBtn" onclick="setResMode('upscale')">
                <input type="checkbox" id="upscaleToggle"> 2x AI
            </label>

            <div style="width:1px;height:20px;background:#333;margin:0 4px;"></div>

            <!-- HDR Group -->
            <div id="hdrGroup" class="btn-group active">
                <label class="toggle-btn" onclick="toggleHdrGroup(this)">
                    <input type="checkbox" id="hdrToggle" checked> HDR
                </label>
                <select id="hdrCount">
                    <option value="3">3x</option>
                    <option value="5">5x</option>
                    <option value="7">7x</option>
                </select>
            </div>

            <label class="toggle-btn active" id="claheBtn" onclick="toggleStyle(this)">
                <input type="checkbox" id="claheToggle" checked> âœ¨ AIé€šé€
            </label>
            <label class="toggle-btn active" id="denoiseBtn" onclick="toggleStyle(this)">
                <input type="checkbox" id="denoiseToggle" checked> ğŸ’§ é™å™ª++
            </label>
            <label class="toggle-btn" id="rawBtn" onclick="toggleStyle(this)">
                <input type="checkbox" id="rawToggle"> PNG
            </label>
        </div>
    </div>

    <div class="viewport" id="viewport">
        <video id="videoPreview" autoplay playsinline muted></video>
        <div id="status-pill">Ready</div>
        
        <!-- å„²å­˜é¸å–®é¢æ¿ -->
        <div id="storage-panel">
            <div class="panel-title">
                é¸æ“‡ç…§ç‰‡ç›®çš„åœ° <span onclick="toggleStoragePanel()" style="cursor:pointer">âœ•</span>
            </div>
            
            <div class="storage-option selected" id="opt-download" onclick="setStorageOption('download')">
                <div class="icon">ğŸ“¥</div>
                <div class="details">
                    <h4>ç€è¦½å™¨ä¸‹è¼‰ (é è¨­)</h4>
                    <p>ç…§ç‰‡å°‡å„²å­˜è‡³ç³»çµ±é è¨­çš„ã€Œä¸‹è¼‰ã€è³‡æ–™å¤¾ã€‚</p>
                </div>
            </div>

            <div class="storage-option" id="opt-local" onclick="setStorageOption('local')">
                <div class="icon">ğŸ“</div>
                <div class="details">
                    <h4>æœ¬åœ°è³‡æ–™å¤¾ / ç¶²çµ¡ç¡¬ç¢Ÿ (NAS)</h4>
                    <p>é¸æ“‡æ›è¼‰çš„ç¶²çµ¡ç¡¬ç¢Ÿè³‡æ–™å¤¾ï¼Œç…§ç‰‡å°‡ç›´æ¥å¯«å…¥ã€‚</p>
                </div>
            </div>

            <div class="storage-option" id="opt-share" onclick="setStorageOption('share')">
                <div class="icon">ğŸ“¤</div>
                <div class="details">
                    <h4>ç³»çµ±åˆ†äº« (Google Space/ç¡¬ç¢Ÿ)</h4>
                    <p>æ‹å®Œå¾Œå½ˆå‡ºåˆ†äº«è¦–çª—ï¼Œç›´æ¥å‚³é€è‡³ Space æˆ– Driveã€‚</p>
                </div>
            </div>

            <div class="storage-option" id="opt-cloud" onclick="setStorageOption('cloud')">
                <div class="icon">â˜ï¸</div>
                <div class="details">
                    <h4>é›²ç«¯è™•ç†ç´€éŒ„</h4>
                    <p>é–‹å•ŸåŒæ­¥ï¼šå°‡æ‹æ”å…ƒæ•¸æ“šèˆ‡è™•ç†ç´€éŒ„å‚™ä»½è‡³é›²ç«¯ã€‚</p>
                </div>
            </div>
        </div>

        <div id="focus-reticle"></div>
        <div id="tracker-box"></div>

        <div id="hud">
            <div class="spinner"></div>
            <div class="hud-text"><div id="hud-main">Processing...</div></div>
            <div id="hud-sub" class="hud-sub">Initializing Pipeline</div>
        </div>
    </div>

    <div class="controls">
        <div class="sliders-col">
            <div class="slider-row ac-focus">
                <span class="label">å°ç„¦</span>
                <input type="range" id="focusSlider" min="0" max="100" step="1" value="0" disabled>
                <div id="afBtn" class="af-btn" onclick="cycleFocusMode()">AF</div>
            </div>
            <div class="slider-row ac-ev">
                <span class="label">EV</span>
                <input type="range" id="evRange" min="-3" max="3" step="0.5" value="0">
                <span id="evText" class="value-disp">0</span>
            </div>
            <div class="slider-row ac-zoom">
                <span class="label">Zoom</span>
                <input type="range" id="zoomSlider" min="1" max="8" step="0.1" value="1" disabled>
                <span id="zoomText" class="value-disp">1x</span>
            </div>
            <div class="slider-row ac-sharp">
                <span class="label">éŠ³åŒ–</span>
                <input type="range" id="sharpSlider" min="0" max="100" value="30">
                <span id="sharpText" class="value-disp">30</span>
            </div>
        </div>
        <div class="shutter-col">
            <div id="shutterBtn" class="shutter" onclick="captureFlow()"></div>
        </div>
    </div>

    <canvas id="cMotion" width="64" height="64"></canvas>

<script type="module">
    // --- Global Storage State ---
    window.storageConfig = {
        mode: 'download',
        directoryHandle: null
    };

    let db, auth, user, appId;

    async function initCloud() {
        if (!window.fbUtils) return;
        const { initializeApp, getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged, getFirestore } = window.fbUtils;
        const firebaseConfig = JSON.parse(__firebase_config);
        const app = initializeApp(firebaseConfig);
        auth = getAuth(app);
        db = getFirestore(app);
        appId = typeof __app_id !== 'undefined' ? __app_id : 'default-camera-app';

        if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
            await signInWithCustomToken(auth, __initial_auth_token);
        } else {
            await signInAnonymously(auth);
        }
        onAuthStateChanged(auth, (u) => { user = u; });
    }

    window.toggleStoragePanel = function() {
        const p = document.getElementById('storage-panel');
        p.style.display = p.style.display === 'flex' ? 'none' : 'flex';
    };

    // Helper to verify directory permissions
    async function verifyPermission(fileHandle, readWrite) {
        const options = {};
        if (readWrite) {
            options.mode = 'readwrite';
        }
        if ((await fileHandle.queryPermission(options)) === 'granted') {
            return true;
        }
        if ((await fileHandle.requestPermission(options)) === 'granted') {
            return true;
        }
        return false;
    }

    window.setStorageOption = async function(mode) {
        if (mode === 'local') {
            if (!('showDirectoryPicker' in window)) {
                alert("æ­¤ç€è¦½å™¨ä¸æ”¯æ´ File System APIï¼Œè«‹æ›´æ› Chrome/Edge æˆ–ä½¿ç”¨é›»è…¦ç‰ˆã€‚");
                return;
            }
            try {
                // è¦æ±‚ç”¨æˆ¶é¸æ“‡ NAS æ›è¼‰è·¯å¾‘æˆ–æœ¬åœ°è³‡æ–™å¤¾
                const handle = await window.showDirectoryPicker({ mode: 'readwrite' });
                if (await verifyPermission(handle, true)) {
                    window.storageConfig.directoryHandle = handle;
                    window.storageConfig.mode = 'local';
                } else {
                    alert("æœªç²å¾—è³‡æ–™å¤¾æˆæ¬Šã€‚");
                    return;
                }
            } catch (e) { 
                console.warn("User cancelled directory picker", e);
                return; 
            }
        } else {
            window.storageConfig.mode = mode;
        }

        // UI æ›´æ–°
        document.querySelectorAll('.storage-option').forEach(opt => opt.classList.remove('selected'));
        document.getElementById(`opt-${mode}`).classList.add('selected');
        
        const modeNames = { download: 'ä¸‹è¼‰', local: 'æœ¬åœ°/NAS', share: 'åˆ†äº«', cloud: 'é›²ç«¯ç´€éŒ„' };
        document.getElementById('currentStorageMode').innerText = modeNames[mode];
        
        if(mode !== 'cloud') setTimeout(toggleStoragePanel, 300);
    };

    // --- Original Logic Implementation ---
    const video = document.getElementById('videoPreview');
    const viewport = document.getElementById('viewport');
    const hud = document.getElementById('hud');
    const hudMain = document.getElementById('hud-main');
    const hudSub = document.getElementById('hud-sub');
    const cameraSelect = document.getElementById('cameraSelect');
    const cvStatus = document.getElementById('cvStatus');
    const shutterBtn = document.getElementById('shutterBtn');
    const focusSlider = document.getElementById('focusSlider');
    const zoomSlider = document.getElementById('zoomSlider');
    const afBtn = document.getElementById('afBtn');
    const trackerBox = document.getElementById('tracker-box');
    const focusReticle = document.getElementById('focus-reticle');
    
    let currentStream, videoTrack, imageCapture;
    let capabilities = {};
    let isOpenCvReady = false;
    let isSafeMode = false;
    let hasTorch = false;
    let currentCameraIndex = 0; 
    let focusModeState = 'af'; 
    let trackingInterval;
    let prevFrameData = null;

    window.onOpenCvReady = function() {
        isOpenCvReady = true;
        cvStatus.innerHTML = '<div class="dot"></div> Engine Ready';
        cvStatus.classList.add('ready');
    };

    async function init() {
        try {
            const stream = await navigator.mediaDevices.getUserMedia({ video: true });
            stream.getTracks().forEach(t => t.stop());
            const devices = await navigator.mediaDevices.enumerateDevices();
            const cams = devices.filter(d => d.kind === 'videoinput');
            cameraSelect.innerHTML = '';
            cams.forEach((d, i) => {
                const opt = document.createElement('option');
                opt.value = d.deviceId;
                opt.text = d.label || `Camera ${i}`;
                opt.dataset.index = i;
                cameraSelect.appendChild(opt);
            });
            if(cams.length > 0) {
                const lastIdx = cams.length - 1;
                cameraSelect.selectedIndex = lastIdx;
                switchCamera(cams[lastIdx].deviceId, lastIdx);
            }
            cameraSelect.onchange = e => {
                const idx = parseInt(e.target.selectedOptions[0].dataset.index);
                switchCamera(e.target.value, idx);
            };
            viewport.addEventListener('click', triggerTapFocus);
            initCloud();
        } catch(e) { alert("ç›¸æ©Ÿå•Ÿå‹•å¤±æ•—: " + e.message); }
    }

    window.toggleFullScreen = function() {
        if (!document.fullscreenEnabled) return;
        try {
            if (!document.fullscreenElement) document.documentElement.requestFullscreen().catch(()=>{});
            else document.exitFullscreen().catch(()=>{});
        } catch(e){}
    };

    async function switchCamera(id, index) {
        setLightMode('off');
        stopTracking();
        currentCameraIndex = index;
        if(currentStream) currentStream.getTracks().forEach(t => t.stop());
        document.getElementById('status-pill').innerText = "Switching...";
        isSafeMode = false;
        try {
            if (index === 2) { 
                await launch({ video: { deviceId: { exact: id }, width: { ideal: 640 }, height: { ideal: 480 } } }, "Wide/VGA");
                isSafeMode = true; 
            } else {
                await launch({ video: { deviceId: { exact: id }, width: { ideal: 4096 }, height: { ideal: 4096 }, aspectRatio: 1.333 } }, "4K UHD");
            }
        } catch(e) {
            try { await launch({ video: { deviceId: { exact: id }, width: { ideal: 640 }, height: { ideal: 480 } } }, "SafeMode"); isSafeMode = true; } catch(e2) {}
        }
        updateUIForCamera();
    }

    function updateUIForCamera() {
        const ultraBtn = document.getElementById('ultraBtn');
        const ultraToggle = document.getElementById('ultraToggle');
        if (isSafeMode || currentCameraIndex === 2) {
            if (ultraToggle.checked) {
                ultraToggle.checked = false;
                ultraBtn.classList.remove('active');
                shutterBtn.classList.remove('ultra-mode');
            }
            ultraBtn.classList.add('disabled');
        } else { ultraBtn.classList.remove('disabled'); }
    }

    async function launch(constraints, label) {
        const stream = await navigator.mediaDevices.getUserMedia(constraints);
        currentStream = stream;
        video.srcObject = stream;
        videoTrack = stream.getVideoTracks()[0];
        if(window.ImageCapture) try { imageCapture = new ImageCapture(videoTrack); } catch(e){}
        capabilities = videoTrack.getCapabilities ? videoTrack.getCapabilities() : {};
        if(capabilities.zoom) {
            zoomSlider.disabled = false;
            zoomSlider.min = capabilities.zoom.min;
            zoomSlider.max = Math.min(capabilities.zoom.max, 8); 
            zoomSlider.value = 1;
        } else { zoomSlider.disabled = true; }
        hasTorch = !!capabilities.torch;
        resetFocusUI();
        document.getElementById('status-pill').innerText = label;
        if(isSafeMode) document.getElementById('status-pill').classList.add("warn-mode");
        else document.getElementById('status-pill').classList.remove("warn-mode");
    }

    zoomSlider.oninput = function() {
        document.getElementById('zoomText').innerText = parseFloat(this.value).toFixed(1) + "x";
        if(videoTrack) videoTrack.applyConstraints({advanced:[{zoom:this.value}]}).catch(()=>{});
    };

    document.getElementById('evRange').oninput = function() { 
        document.getElementById('evText').innerText = this.value;
        if(capabilities.exposureCompensation) videoTrack.applyConstraints({advanced:[{exposureCompensation:parseFloat(this.value)}]}).catch(()=>{});
    };
    
    document.getElementById('sharpSlider').oninput = function() { document.getElementById('sharpText').innerText = this.value; };

    window.setLightMode = async function(mode) {
        if(!videoTrack) return;
        document.querySelectorAll('.light-btn').forEach(b => b.classList.remove('active'));
        document.getElementById(`light-${mode}`).classList.add('active');
        try {
            if (mode === 'torch') await videoTrack.applyConstraints({ advanced: [{ torch: true }] });
            else if (hasTorch) await videoTrack.applyConstraints({ advanced: [{ torch: false }] });
        } catch(e) {}
        window.currentLightMode = mode;
    }

    async function triggerTapFocus(e) {
        if (!videoTrack) return;
        if (focusModeState === 'track') stopTracking();
        resetFocusUI();
        const rect = viewport.getBoundingClientRect();
        focusReticle.style.left = `${e.clientX - rect.left}px`;
        focusReticle.style.top = `${e.clientY - rect.top}px`;
        focusReticle.style.display = 'block';
        focusReticle.classList.remove('focusing');
        void focusReticle.offsetWidth; 
        focusReticle.classList.add('focusing');
        try { await videoTrack.applyConstraints({ advanced: [{ focusMode: 'auto' }] }); } catch(err) {
            try { await videoTrack.applyConstraints({ advanced: [{ focusMode: 'continuous' }] }); } catch(e) {}
        }
    }

    window.cycleFocusMode = function() {
        if(focusModeState === 'af') {
            if(capabilities.focusMode && capabilities.focusMode.includes('manual')) {
                focusModeState = 'mf';
                afBtn.innerText = "MF"; afBtn.className = "af-btn manual";
                focusSlider.disabled = false;
                videoTrack.applyConstraints({ advanced: [{ focusMode: 'manual' }] });
            } else { startTrackingMode(); }
        } else if(focusModeState === 'mf') { startTrackingMode(); }
        else { resetFocusUI(); videoTrack.applyConstraints({ advanced: [{ focusMode: 'continuous' }] }); }
    };

    focusSlider.oninput = function() {
        if(focusModeState === 'mf') videoTrack.applyConstraints({ advanced: [{ focusDistance: this.value / 100 }] });
    };

    function resetFocusUI() {
        stopTracking();
        focusModeState = 'af'; afBtn.innerText = "AF"; afBtn.className = "af-btn";
        focusSlider.disabled = true;
    }

    function startTrackingMode() {
        focusModeState = 'track'; afBtn.innerText = "ğŸ¯"; afBtn.className = "af-btn tracking";
        trackerBox.style.display = 'block';
        if(trackingInterval) clearInterval(trackingInterval);
        const cvs = document.getElementById('cMotion');
        const ctx = cvs.getContext('2d');
        trackingInterval = setInterval(() => {
            if(video.readyState !== 4) return;
            ctx.drawImage(video, 0, 0, 64, 64);
            const frame = ctx.getImageData(0, 0, 64, 64);
            const data = frame.data;
            if(prevFrameData) {
                let avgX = 0, avgY = 0, count = 0;
                for(let i=0; i<data.length; i+=16) { 
                    const diff = Math.abs(data[i] - prevFrameData[i]) + Math.abs(data[i+1] - prevFrameData[i+1]) + Math.abs(data[i+2] - prevFrameData[i+2]);
                    if(diff > 30) { const idx = i / 4; avgX += (idx % 64); avgY += Math.floor(idx / 64); count++; }
                }
                if(count > 5) { 
                    const cx = (avgX / count) / 64 * 100; const cy = (avgY / count) / 64 * 100;
                    trackerBox.style.left = `calc(${cx}% - 40px)`; trackerBox.style.top = `calc(${cy}% - 40px)`;
                    trackerBox.style.borderColor = "#00ff88"; 
                } else { trackerBox.style.borderColor = "#555"; }
            }
            prevFrameData = data;
        }, 100);
    }

    function stopTracking() { if(trackingInterval) clearInterval(trackingInterval); trackerBox.style.display = 'none'; prevFrameData = null; }

    window.captureFlow = async function() {
        if(!isOpenCvReady) { alert("Engine not ready."); return; }
        hud.style.display = 'flex'; hudMain.innerText = "Capturing..."; hudSub.innerText = "Acquiring sensor data";
        const isHdr = document.getElementById('hdrToggle').checked;
        const isUltra = document.getElementById('ultraToggle').checked;
        const isUpscale = document.getElementById('upscaleToggle').checked;
        try {
            let baseCanvas;
            if(isHdr) {
                const count = parseInt(document.getElementById('hdrCount').value);
                const step = 0.3; const frames = []; const centerIndex = Math.floor(count / 2);
                for(let i=0; i<count; i++) {
                    const ev = (i - centerIndex) * step;
                    hudSub.innerText = `HDR EV ${ev.toFixed(1)} (${i+1}/${count})`;
                    if(capabilities.exposureCompensation) await videoTrack.applyConstraints({advanced:[{exposureMode: 'continuous', exposureCompensation: ev}]});
                    await new Promise(r => setTimeout(r, 400));
                    frames.push(await grabFrame());
                }
                if(capabilities.exposureCompensation) await videoTrack.applyConstraints({advanced:[{exposureCompensation: 0}]});
                hudMain.innerText = "Smart HDR Merging...";
                baseCanvas = await mergeHDROpenCV(frames);
            } else {
                const opts = (window.currentLightMode === 'flash') ? {fillLightMode: 'flash'} : {};
                baseCanvas = await grabFrame(true, opts);
            }
            if (isUltra) await processUltra100MP(baseCanvas);
            else if (isUpscale) await processUpscale2x(baseCanvas);
            else await processStandard(baseCanvas);
        } catch(e) { alert("Error: " + e.message); hud.style.display = 'none'; }
    };

    async function grabFrame(usePhotoAPI = false, opts = {}) {
        if(usePhotoAPI && imageCapture) try {
            const blob = await imageCapture.takePhoto(opts);
            const bmp = await createImageBitmap(blob);
            const c = document.createElement('canvas'); c.width = bmp.width; c.height = bmp.height;
            c.getContext('2d').drawImage(bmp, 0, 0); return c;
        } catch(e) { }
        const c = document.createElement('canvas'); c.width = video.videoWidth; c.height = video.videoHeight;
        c.getContext('2d').drawImage(video, 0, 0); return c;
    }

    async function mergeHDROpenCV(frames) {
        const centerIdx = Math.floor(frames.length / 2);
        const w = frames[0].width; const h = frames[0].height;
        let mats = []; for(let f of frames) mats.push(cv.imread(f));
        const res = new cv.Mat(); const temp = new cv.Mat();
        mats[centerIdx].convertTo(res, cv.CV_32F);
        for(let i=0; i<centerIdx; i++) { mats[i].convertTo(temp, cv.CV_32F); cv.addWeighted(res, 0.7, temp, 0.3, 0, res); }
        for(let i=centerIdx+1; i<frames.length; i++) { mats[i].convertTo(temp, cv.CV_32F); cv.addWeighted(res, 0.7, temp, 0.3, 0, res); }
        res.convertTo(temp, cv.CV_8UC4);
        const c = document.createElement('canvas'); c.width = w; c.height = h; cv.imshow(c, temp);
        for(let m of mats) m.delete(); res.delete(); temp.delete(); return c;
    }

    async function processUpscale2x(canvas) {
        hudMain.innerText = "AI Upscaling..."; hudSub.innerText = "2x Native Super-Res";
        await new Promise(r => setTimeout(r, 50)); 
        let upCanvas = document.createElement('canvas'); upCanvas.width = canvas.width * 2; upCanvas.height = canvas.height * 2;
        const ctx = upCanvas.getContext('2d'); ctx.imageSmoothingEnabled = true; ctx.imageSmoothingQuality = 'high';
        ctx.drawImage(canvas, 0, 0, upCanvas.width, upCanvas.height);
        const src = cv.matFromImageData(ctx.getImageData(0, 0, upCanvas.width, upCanvas.height));
        await processEnhancePipeline(src, "2x_AI"); src.delete();
    }

    async function processUltra100MP(canvas) {
        hudMain.innerText = "Ultra Processing..."; await new Promise(r => setTimeout(r, 50)); 
        try {
            const src = cv.imread(canvas); const dst = new cv.Mat();
            cv.resize(src, dst, new cv.Size(src.cols * 3, src.rows * 3), 0, 0, cv.INTER_LANCZOS4);
            const outCanvas = document.createElement('canvas'); outCanvas.width = dst.cols; outCanvas.height = dst.rows;
            cv.imshow(outCanvas, dst); src.delete(); dst.delete();
            downloadCanvas(outCanvas, "Ultra_100MP");
        } catch(e) { processUpscale2x(canvas); }
    }

    async function processStandard(canvas) {
        hudMain.innerText = "AI Processing..."; await new Promise(r => setTimeout(r, 50));
        try { const src = cv.imread(canvas); await processEnhancePipeline(src, "Standard"); src.delete(); }
        catch(e) { downloadCanvas(canvas, "Raw"); }
    }

    async function processEnhancePipeline(srcMat, prefix) {
        const dst = new cv.Mat(); const lab = new cv.Mat(); const labPlanes = new cv.MatVector();
        cv.cvtColor(srcMat, lab, cv.COLOR_RGBA2RGB); cv.cvtColor(lab, lab, cv.COLOR_RGB2Lab); cv.split(lab, labPlanes);
        const L = labPlanes.get(0); const A = labPlanes.get(1); const B = labPlanes.get(2);
        if(document.getElementById('denoiseToggle').checked) {
            hudSub.innerText = "Denoising..."; cv.GaussianBlur(A, A, new cv.Size(7, 7), 2); cv.GaussianBlur(B, B, new cv.Size(7, 7), 2);
        }
        if(document.getElementById('claheToggle').checked || document.getElementById('hdrToggle').checked) {
            const clahe = new cv.CLAHE(2.0, new cv.Size(8, 8)); clahe.apply(L, L); clahe.delete();
        }
        const sharpVal = parseInt(document.getElementById('sharpSlider').value);
        if(sharpVal > 0) {
            const blurred = new cv.Mat(); cv.GaussianBlur(L, blurred, new cv.Size(0, 0), 3);
            cv.addWeighted(L, 1 + (sharpVal/40), blurred, -(sharpVal/40), 0, L); blurred.delete();
        }
        labPlanes.set(0, L); labPlanes.set(1, A); labPlanes.set(2, B);
        cv.merge(labPlanes, lab); cv.cvtColor(lab, dst, cv.COLOR_Lab2RGB);
        const outCanvas = document.createElement('canvas'); outCanvas.width = dst.cols; outCanvas.height = dst.rows;
        cv.imshow(outCanvas, dst); dst.delete(); lab.delete(); L.delete(); A.delete(); B.delete(); labPlanes.delete();
        downloadCanvas(outCanvas, prefix);
    }

    // --- Fixed Robust Storage Logic with Explicit Permission Handling ---
    async function downloadCanvas(canvas, prefix) {
        const mode = window.storageConfig.mode;
        hudMain.innerText = "Saving...";
        hudSub.innerText = `Target: ${mode.toUpperCase()}`;
        
        const isPng = document.getElementById('rawToggle').checked;
        const mime = isPng ? 'image/png' : 'image/jpeg';
        const fileName = `IMG_${Date.now()}_${prefix}.${isPng ? 'png' : 'jpg'}`;

        const finish = () => { 
            canvas.width = 1; canvas.height = 1; 
            hud.style.display = 'none'; 
        };

        // 1. Cloud Record (FireStore Metadata Sync)
        if (mode === 'cloud' && user && window.fbUtils) {
            try {
                const { collection, addDoc, serverTimestamp } = window.fbUtils;
                await addDoc(collection(db, 'artifacts', appId, 'public', 'data', 'captures'), {
                    fileName, timestamp: serverTimestamp(), user: user.uid, type: prefix
                });
            } catch(e) { console.error("Cloud log failed", e); }
        }

        // 2. Local Directory / NAS Mode (Highest Priority)
        if (mode === 'local' && window.storageConfig.directoryHandle) {
            try {
                const handle = window.storageConfig.directoryHandle;
                
                // CRITICAL FIX: Re-verify permission before every write to avoid SecurityError
                if (!(await verifyPermission(handle, true))) {
                    alert("æ¬Šé™éæœŸæˆ–é­æ‹’çµ•ï¼Œè«‹é‡æ–°è¨­å®šå„²å­˜è³‡æ–™å¤¾ã€‚");
                    finish();
                    return;
                }

                const fileHandle = await handle.getFileHandle(fileName, { create: true });
                const writable = await fileHandle.createWritable();
                
                canvas.toBlob(async (blob) => {
                    try {
                        await writable.write(blob);
                        await writable.close();
                        finish();
                    } catch(err) {
                        console.error("Write failed", err);
                        alert("æª”æ¡ˆå¯«å…¥å¤±æ•—ï¼Œè«‹ç¢ºèªç¡¬ç¢Ÿç©ºé–“æˆ–è³‡æ–™å¤¾æ¬Šé™ã€‚");
                        finish();
                    }
                }, mime, 0.95);
                return; 
            } catch (err) {
                console.error("Local/NAS handle error", err);
                alert("å­˜å–è³‡æ–™å¤¾å¤±æ•—ã€‚åŸå› ï¼š" + err.message);
                finish();
                return;
            }
        }

        // 3. System Share Mode (Bridge to Google Space / Chat / Drive)
        if (mode === 'share' && navigator.share) {
            canvas.toBlob(async (blob) => {
                const file = new File([blob], fileName, { type: mime });
                try {
                    await navigator.share({
                        files: [file],
                        title: 'AI 100MP Pro Capture',
                        text: 'Captured via AI Pro Camera Pipeline'
                    });
                    finish();
                } catch (e) {
                    console.warn("Share failed, falling back to download", e);
                    triggerStandardDownload(blob, fileName, finish);
                }
            }, mime, 0.95);
            return;
        }

        // 4. Standard Download (Fallback)
        canvas.toBlob((blob) => {
            triggerStandardDownload(blob, fileName, finish);
        }, mime, 0.95);
    }

    function triggerStandardDownload(blob, name, callback) {
        const link = document.createElement('a');
        link.download = name;
        link.href = URL.createObjectURL(blob);
        link.click();
        setTimeout(() => {
            URL.revokeObjectURL(link.href);
            callback();
        }, 300);
    }

    window.toggleStyle = (el) => {
        const chk = el.querySelector('input'); chk.checked = !chk.checked;
        el.classList.toggle('active', chk.checked);
    };
    window.toggleHdrGroup = (label) => {
        const group = label.parentElement; const chk = label.querySelector('input');
        chk.checked = !chk.checked; group.classList.toggle('active', chk.checked);
    };
    window.setResMode = (mode) => {
        const ultraEl = document.getElementById('ultraBtn'); const upscaleEl = document.getElementById('upscaleBtn');
        const ultraChk = document.getElementById('ultraToggle'); const upscaleChk = document.getElementById('upscaleToggle');
        if(mode === 'ultra') { ultraChk.checked = !ultraChk.checked; upscaleChk.checked = false; }
        else { upscaleChk.checked = !upscaleChk.checked; ultraChk.checked = false; }
        ultraEl.classList.toggle('active', ultraChk.checked); upscaleEl.classList.toggle('active', upscaleChk.checked);
        shutterBtn.classList.remove('ultra-mode', 'upscale-mode');
        if(ultraChk.checked) shutterBtn.classList.add('ultra-mode');
        else if(upscaleChk.checked) shutterBtn.classList.add('upscale-mode');
    };

    init();
</script>
</body>
</html>
